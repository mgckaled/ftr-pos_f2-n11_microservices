# Fundamento de Microsserviços

## Aula 1: Microsserviços - Fundamentos, Vantagens e Desafios

A primeira aula explora os fundamentos da arquitetura de microsserviços, desmistificando conceitos essenciais e esclarecendo que se trata primariamente de uma arquitetura de infraestrutura, não de código. Microsserviços são caracterizados por serviços independentemente implantáveis, modelados em torno de domínios de negócio específicos, onde cada serviço pode utilizar tecnologias e bancos de dados distintos conforme suas necessidades. A aula demonstra vantagens significativas como escalabilidade direcionada, onde serviços podem ser escalados individualmente baseado em suas cargas específicas, infraestrutura otimizada por serviço, e desenvolvimento paralelo eficiente em equipes grandes. Utilizando o exemplo prático de um sistema de encurtamento de URLs, ilustra-se como o serviço de Analytics pode operar em múltiplas instâncias processando milhões de acessos, enquanto o serviço de Encurtamento permanece em infraestrutura modesta, demonstrando a granularidade na alocação de recursos.

Contudo, a aula enfatiza que microsserviços introduzem complexidades substanciais que não devem ser subestimadas. Cada desafio presente em monolitos multiplica-se pelo número de serviços, incluindo observabilidade, debugging distribuído, gestão de latência e consistência de dados entre serviços isolados. A necessidade de cada serviço possuir seu próprio banco de dados, comunicando-se exclusivamente através de protocolos como HTTP, gRPC, Kafka ou RabbitMQ, cria desafios de consistência eventual e transações distribuídas que exigem padrões como Saga Pattern e CQRS. A aula conclui com orientação pragmática: microsserviços fazem sentido para organizações grandes com centenas de desenvolvedores, domínios de negócio bem definidos e maturidade em DevOps, enquanto monolitos bem estruturados frequentemente representam escolha mais apropriada para equipes menores e produtos em validação inicial.

Para detalhamento completo dos conceitos, vantagens, desafios, padrões arquiteturais, ferramentas do ecossistema e exemplos práticos, consulte o [documento completo da Aula 1](.github/docs/content/a1.md).

## Aula 2: Comunicação em Microsserviços - Padrões, Protocolos e Práticas

A segunda aula aprofunda-se nos mecanismos de comunicação entre microsserviços, explorando os dois paradigmas fundamentais: comunicação síncrona e assíncrona. A comunicação síncrona, realizada através de protocolos como HTTP/REST e gRPC, é apropriada quando respostas imediatas são necessárias para decisões de negócio, como validação de estoque antes de criar pedido ou autenticação de usuário. O gRPC destaca-se por utilizar HTTP/2 e Protocol Buffers, oferecendo performance superior através de serialização binária eficiente e tipagem forte garantida por contratos em arquivos `.proto`. Entretanto, a comunicação síncrona introduz acoplamento temporal direto entre serviços, onde a indisponibilidade de uma dependência compromete imediatamente a operação requisitante. Este acoplamento, embora apropriado para operações críticas que exigem validação em tempo real, contradiz o princípio fundamental de independência operacional dos microsserviços.

A comunicação assíncrona emerge como padrão predominante para desacoplamento efetivo, mediada por message brokers como Apache Kafka e RabbitMQ que implementam o padrão Publish/Subscribe. Neste modelo, produtores publicam eventos em tópicos sem conhecimento de consumidores, enquanto consumidores subscrevem-se a tópicos de interesse processando mensagens em seu próprio ritmo. Apache Kafka, posicionado como plataforma de streaming de eventos distribuída, oferece arquitetura baseada em tópicos particionados com retenção configurável de mensagens, Consumer Groups para paralelização horizontal e capacidade de reprocessamento histórico, sendo ideal para event sourcing e stream processing. RabbitMQ, implementando protocolo AMQP, foca em entrega garantida com roteamento complexo através de exchanges e filas, adequado para job queues e tarefas em background. A aula demonstra implementações práticas utilizando KafkaJS em TypeScript, incluindo contratos de mensagens tipados com Zod, estratégias de resiliência como Circuit Breaker e Dead Letter Queues, padrões avançados como Saga Pattern para transações distribuídas, e observabilidade através de Correlation IDs para rastreamento end-to-end em sistemas distribuídos.

Para detalhamento completo sobre protocolos síncronos e assíncronos, implementações práticas com exemplos de código TypeScript, comparação entre Kafka e RabbitMQ, padrões de resiliência e estratégias de observabilidade, consulte o [documento completo da Aula 2](.github/docs/content/a2.md).

## Aula 3: Persistência em Microsserviços - Desafios, Padrões e Estratégias

A terceira aula aborda o desafio crucial da persistência de dados em arquiteturas de microsserviços, explorando o princípio fundamental "Database per Service" que estabelece que cada microsserviço deve possuir controle exclusivo sobre seu armazenamento de dados. Este isolamento, embora essencial para independência operacional e autonomia tecnológica, introduz complexidades substanciais relacionadas à duplicação controlada de dados, consistência eventual e coordenação de transações distribuídas. A aula demonstra como serviços distintos podem utilizar tecnologias de persistência heterogêneas otimizadas para suas necessidades específicas, exemplificando com MongoDB para flexibilidade documental no serviço de Encurtamento de URLs e ClickHouse otimizado para agregações analíticas em grandes volumes temporais no serviço de Analytics. A duplicação de dados não representa falha arquitetural mas estratégia deliberada, onde cada serviço mantém apenas dados essenciais para sua operação, sincronizados via eventos assíncronos publicados pelo serviço autoritativo. Utilizando exemplo prático de e-commerce com serviços Orders, Invoices e Shipping, ilustra-se como entidade Customer possui cópias parciais em cada serviço, contendo exclusivamente atributos necessários para suas responsabilidades específicas.

O conceito de Soft References substitui Foreign Keys tradicionais em contextos distribuídos, permitindo referências entre entidades de serviços distintos sem constraints de integridade do banco de dados, com prefixação por origem facilitando rastreamento como `orders_customer_id` ou `inventory_product_id`. A aula aprofunda-se em padrões avançados essenciais para coordenação de operações complexas, apresentando Saga Pattern para gerenciamento de transações distribuídas através de sequências de transações locais com compensações, demonstrando implementação de orquestrador que garante reversão de estado mediante falhas sem acoplamento temporal de Two-Phase Commit. Event Sourcing emerge como padrão invertendo modelo tradicional de persistência, armazenando sequência imutável de eventos representando todas mudanças ao invés de sobrescrever estado atual, fornecendo auditoria completa e capacidade de reconstrução temporal. CQRS (Command Query Responsibility Segregation) complementa Event Sourcing separando modelos de escrita que modificam Event Store e leitura que consultam projeções otimizadas construídas a partir de eventos, permitindo otimizações específicas para comandos e queries com trade-off de complexidade operacional adicional.

Para detalhamento completo sobre Database per Service, duplicação controlada de dados, Soft References, reconciliação e auditoria, Saga Pattern com orquestração e coreografia, Event Sourcing, CQRS, comparação de tecnologias de bancos de dados e estratégias de migração de monolito, consulte o [documento completo da Aula 3](.github/docs/content/a3.md).
