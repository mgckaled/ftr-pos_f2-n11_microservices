# Transcrição: 7. Idempotência

Um outro conceito aqui para a nossa saga de fundamentos, de conceitos de microserviços, é o conceito de idempotência. E aqui, se você trabalha com back-end, já fez entrevistas, cara, se prepara, porque esse aqui é um dos conceitos mais importantes que eu acho para uma pessoa que começa a avançar os seus estudos dentro de back-end, que é o seguinte... Imagina o que acontece... A gente tem aqui o front-end, O usuário cria uma URL encurtada. Essa URL encurtada envia um evento para o Kafka, falando que a URL foi criada. Esse evento é ouvido pelo sistema de Analytics, que cria essa URL também no banco de dados de Analytics. Até agora, a gente já falou bastante sobre isso e é um fluxo que você já está acostumado. Agora, imagina que aqui o Analytics, quando ele ouve essa mensagem de URL criada, ele tenha mais de uma operação acontecendo. Então, além de ele salvar no banco, ele também salva essa URL no Redis para que esse click count seja armazenado em um banco de dados chave-valor para que seja mais rápido não salvar isso no Postgres, onde é um banco que não é geralmente feito para isso. Então, o Analytics faz duas operações. Ele escreve tanto no Redis quanto escreve no Postgres com o click house. E aí, imagina que essas operações são feitas uma abaixo da outra. E aí, primeiro ele salva no Redis. Então imagina que ele salvou no Redis, e depois ele vai lá e tenta salvar no Postgres. Só que quando ele for salvar no Postgres, dá um erro. E aí, o que acontece? Geralmente, nesses sistemas, o Kafka, quando ele consumiu essa mensagem do Kafka, ele vai falar, eu não vou marcar essa mensagem como lida porque deu erro então eu vou fazer uma retentativa vou tentar processar essa imagem essa mensagem de novo automaticamente pelo menos mais umas três vezes beleza só que se eu processar essa mensagem de novo você não concorda comigo que nós vamos ter essa linha, essa execução, e ele vai tentar salvar no Redis de novo, sendo que antes já tinha salvo no Redis, já tinha dado certo. Então, a idempotência é uma forma da gente evitar, dentro de uma arquitetura de microserviços, que mensagens sejam reprocessadas dado que elas já tiveram sucesso antes, em algum momento. Então, o que acontece? Trazendo isso para o código, vai ficar um pouquinho mais claro de escrever, né? Então, olha só... Eu também tenho uma documentação de impotência, que eu deixei aqui disponível para você dentro do código. Aqui eu tenho um exemplo, né? Então, olha só... Quando o encurtador de URL recebe uma requisição para criar uma URL, ele não só publica no Kafka os dados daquela URL, mas ele gera um ID único deste evento de criação de URL. E este id único, mesmo que o usuário... Se o usuário chamasse essa função de criar URL com os mesmos parâmetros, o que seria impossível, porque a gente gera um id automático para ele, ele daria o mesmo id. Então, não é um id aleatório, é um id baseado nos dados que foram enviados, para a gente deixar essa requisição unificada, única. E ele publica esse evento para o Kafka, ele coloca esse id único junto nessa mensagem quando o analytics consumir ele vai bater lá no banco de dados e vai olhar opa esse evento já foi consumido antes já foi processado antes se sim ele nem vai processar de novo se não ele vai processar então olha só no código como é que fica isso né então se a gente for pegar aqui ó o url shortener entrar aqui na na rota de criação de url olha só eu recebo o url posso receber um custom code ou ele vai gerar automaticamente e aí eu gero aqui ó olha só aqui embaixo aqui era só um código que eu deixei de exemplo deixa eu apagar tudo isso aqui beleza olha só eu gero aqui dentro um url a um deixa eu ver aqui um url id é o que ele está usando deixa eu lembrar aqui qual que é o id que ele está usando para ender potência a gente consegue enxergar isso aqui no sistema de analytics quando a gente recebe a mensagem aqui ó no url created event então ele procura pelo event id que está no payload então Aqui, Event ID. Então, ele basicamente cria um ID único aqui dentro, na mensagem, e ele coloca esse ID único na mensagem. O que acontece? Quando o sistema de analytics vai processar essa mensagem, ele busca num banco de dados, numa tabela do banco de dados, que a gente pode ver... Aqui, ProcessedEvents, que guarda os IDs dos eventos e se eles foram processados já em algum momento ou não. E aí, o que ele faz? Ele busca se esse evento que já foi processado, ele não tenta processar de novo, ele dá um return. Senão, ele vai e faz realmente a inserção. Isso permite com que, se aqui no CreateURL eu disparar essa mensagem aqui, E em algum momento ela for repetida, ou seja, esse analítico se receber a mesma mensagem duas ou três vezes, o que pode acontecer em um sistema distribuído, é muito comum, ele não vai reprocessar mensagens que já foram processadas anteriormente. Então, a idempotência nada mais é do que isso. Você manter uma referência para mensagens que já foram processadas em algum momento para não repeti-las. Inclusive, a própria... A gente pode também chamar isso, algumas ferramentas chamam isso de deduplication ID. O Stripe, na API do Stripe, se a gente for procurar aqui... Todas as requisições do Stripe, a gente pode enviar também essa idpotency key, que é um id gerado pela nossa aplicação, a fim de evitar que algo seja executado duas vezes lá dentro da API. Quando a gente trabalha com sistemas distribuídos, isso é muito importante. todo o sistema tem que controlar e de potência. Então, veja que cada coisinha, cada decisão que a gente toma dentro de microserviços, tem um monte de coisa que a gente vai ter que tomar cuidado. Por isso que é muito importante, antes de você tomar a decisão de utilizar microserviços, pensar muito bem se é isso que você está querendo seguir na sua aplicação. Mas se você for trabalhar em uma empresa grande, todos esses conceitos que eu estou te mostrando aqui, eles vão ser super úteis. Por isso que a gente está dando tanto foco nesse módulo de fundamentos aqui em trazer realmente os fundamentos, os conceitos. A gente não está codando tudo do zero juntos, mas eu quero que você tenha essa base conceitual muito forte na sua cabeça e claro, um exemplo de código disponível para você consultar como isso é implementado e a documentação aqui também disponível para você entender como isso funciona no mundo real para consulta posterior
