# Transcrição: 5 Fundamento API Gateway

O outro próximo conceito que a gente precisa dominar quando trabalha com microsserviços é o conceito de API Gateway, porque até então, que a gente tem dois serviços aqui, está muito fácil entender como o front-end pode se comunicar com tudo isso, porque ele pode fazer requisições HTTP tanto para o serviço de shortener, quanto para o serviço de analytics, e isso seria muito simples. Só lá no front-end eu tenho um arquivo .env, que guarda a URL, a referência da URL onde cada um desses serviços aqui tá operando, tá funcionando, a URL do back-end ali, e aí ele faz a chamada para esses dois serviços. Mas imagina que daqui a pouco eu tenha 10, 50 ou até mil serviços diferentes Cara, será que o front-end vai ter que fazer requisições para cada um desses serviços de forma individual, guardar referência para o URL de cada um desses serviços aqui de forma individualizada? E não, a verdade é que não. A gente geralmente tem um carinha que a gente chama de API Gateway, que é um carinha que fica operando entre o front-end e os nossos demais serviços, e ele serve justamente para centralizar um único local onde a gente vai ter todas as chamadas HTTP da nossa aplicação. Isso faz com que o front-end só precise se comunicar com o API Gateway. O API Gateway... por sua vez, se comunica com os outros serviços que a gente tem, repassando a requisição caso seja necessário. Então, por que caso seja necessário? Porque lá agora, no API Gateway, a gente vai fazer uma configuração. A gente vai falar que toda vez que o usuário chamar localhost, pensando que a gente está rodando em desenvolvimento... Toda vez que ele chamar localhost, imagina que o API Gateway esteja rodando aqui na porta 80 mesmo, então não precisa ter a porta indicada aqui. barra shortener, barra asterisco, ou seja, toda requisição do front-end que partir para esta rota aqui, shortener, e aí pode vir qualquer coisa aqui, o API Gateway vai enviar lá para dentro, vou até botar dessa forma aqui que fica mais fácil... ele vai enviar lá para dentro do nosso serviço de shortener. Quando o front-end fizer uma requisição para qualquer rota, começando com analytics, ele vai enviar para esse sistema aqui. Então, o API gate nada mais é do que um proxy, uma aplicação que repassa uma requisição que está vindo do front-end, para o serviço correto. E aqui dentro, por ele ser uma aplicação por si só, a gente pode adicionar coisas nele aqui que facilitem a gente lidar com algumas coisas que são muito comuns, por exemplo, rate limit. Então, imagina que o FrontEnd tem um usuário louco lá, que fica dando F5 sem parar na aplicação e cada vez que ele dá um F5 dispara 30 requisições. Aqui, ao invés de a gente configurar um máximo de requisições que o usuário pode fazer por serviço, a gente pode configurar no API Gateway. Então, a gente fala... Olha, cada usuário, baseado no IP ou no ID do usuário autenticado, pode fazer 30 requisições... Ou melhor, sei lá... 60 requisições por minuto. E aí, aqui no API Gateway, não interessa se a requisição está sendo para Analytics ou Shortener, ele vai limitar. Aqui mesmo no API Gateway, eu estou retornando um HTTP 429, geralmente que é usado para isso. HTTP 429... Too many requests? Exato. Para retornar isso para o usuário. Então, a gente tem... esse controle aqui no API Gateway. Outra coisa que a gente pode fazer no API Gateway, e conecta muito com o que a gente estava falando na aula passada, é a questão de autenticação. Então, o que acontece? Eu posso falar aqui no API Gateway, por exemplo, que todas as rotas do serviço de shortener ou do serviço de analytics, elas precisam ser autenticadas. Então, ao invés de eu fazer a validação do JWT, por serviço, eu posso fazer a validação aqui no API Gateway. Então, ao invés de essa requisição que acontece do API Gateway para o shortener acontecer independente do usuário estar autenticado, e aí lá no serviço de encurtamento de URL eu validar a autenticação do usuário, eu posso fazer aqui no próprio API Gateway, fazer aqui nesse caso uma requisição lá para o serviço de auth para aquele endpoint de JWKS, pegar a chave pública, validar a requisição do usuário e só permitir ele seguir, caso ela seja validada. Inclusive, quando eu permito ele seguir, eu posso enviar já os dados que estão contidos no payload do token. Então, por exemplo, um user ID já pode chegar pronto aqui no shortener, sabendo que isso aqui foi validado, que esse ID realmente é o ID do usuário logado. E aí, o shortener não precisa validar essa informação, que é exatamente o que acontece aqui na nossa aplicação. Lembra que eu te mostrei? Então, aqui se a gente pegar uma rota do serviço de Analytics, a gente vai ver que ela recebe nos headers aqui o XUSERID, que é exatamente o ID do usuário que já foi validado pelo API Gateway. Eu não preciso fazer essa revalidação. E esse API Gateway aqui, a gente está subindo ele aqui... Deixa eu até... para aqui a minha outra aplicação, a gente está subindo usando o Kong nesse caso, mas existem vários API Gateway disponíveis, tem o Trick, tem vários disponíveis aí no mercado. E aí, aqui que está a configuração do Kong, a gente basicamente... Na verdade, aqui a gente só sobe, a configuração dele fica dentro dessa pasta Kong.yml, E aqui dentro, eu declaro quais são os meus serviços, quais portas cada um desses serviços está rodando. Então, cada serviço vai estar rodando em um endpoint, então o API Gateway eu só faço um remap. Então, eu falo que toda rota que começar com //auth ou //auth, //auth e vindo qualquer coisa aqui, vai redirecionar para o meu serviço de autenticação, GET ou POST. Rotas que começarem com api-urls vão ser redirecionadas para o serviço de urlshortener. Rotas que começarem com api-analytics vão redirecionar para o meu serviço de analytics que está rodando na porta 3001. E veja, esses dois serviços de urlshortener e de analytics, eles têm aqui embaixo um plugin configurado, que é o JWT, e aí ele vai fazer essa verificação para a gente de forma automática, usando aqui embaixo esse consumer que a gente configurou. A gente está passando o secret dele aqui diretamente, mas o ideal é que esse consumer aqui fosse buscar lá no JWKS, como eu tinha falado lá no serviço de autenticação. E aí até para a gente ver, se eu entrar aqui, eu acho que eu consigo mostrar aqui... Mesmo com o código tendo alguns errinhos que eu ainda tô arrumando. Se eu subo aqui o nosso API Gateway, ele tá rodando aqui no Docker Compose, ele tá rodando o admin nessa URL aqui. Docker PS... O API Gateway tá falhando por algum motivo. Deixa eu pegar aqui. Docker... Nuclear locks. Eu estou com alguns errinhos no JWT que eu vou ter que verificar. Mas basicamente, o Kong, quando você pegar esse código e rodar, ele vai estar funcionando 100%, mas você vai conseguir visualizar ali... Na verdade, só isso que eu te mostrei por um arquivo de configuração, você vai conseguir visualizar pela interface, caso você prefira. Geralmente, eu acabo nem entrando muito na interface do Kong, porque ela é só uma leitura mais bonitinha para esse próprio arquivo que está disponível aqui dentro.
