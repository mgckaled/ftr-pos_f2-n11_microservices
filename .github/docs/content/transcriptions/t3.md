# Transcrição: 3. Persistência em Microsserviços

O próximo assunto que a gente precisa falar dentro de microserviços, que é um desafio assim como a parte de comunicação, é a parte de persistência de dados. Porque lembra que eu falei que cada serviço, bem provavelmente, na verdade, se isso não acontecer, provavelmente você nem está aplicando microserviços, cada serviço precisa ter o seu próprio banco de dados e não necessariamente um banco de dados, mas ele precisa ter a sua própria estrutura de persistência. Isso implica que muitas vezes a gente tem alguns desafios interessantes, como por exemplo, imagina que a gente está criando, como eu tinha falado, esse serviço de pedidos e o serviço de estoque. Imagina que daqui a pouco a gente tem um outro serviço, que é o serviço de nota fiscal. E aí o que acontece? Quando o cliente emite um pedido aqui dentro, a gente precisa fazer a emissão da nota fiscal desse pedido certo e aí a gente pode enviar uma mensagem para esse serviço como por exemplo olha eu tive um pedido um pedido que foi criado então eu teria todos os dados do produto né do pedido e tudo mais E aí, eu poderia... Olha, o cliente que criou esse pedido foi o cliente com ID 123. Só que o que acontece? Os dados desse cliente aqui que fez esse pedido, eles estão no banco de dados deste serviço aqui, que é o serviço de pedidos. E aí, lá no serviço de invoices, eu não posso ir até o serviço o banco de dados do serviço de pedidos para pegar os dados do cliente para saber o CPF, o endereço para fazer a emissão da nota fiscal? Isso não faz sentido? Então, uma das grandes dificuldades que a gente tem e, na verdade, é o que a gente vai falar agora, é a questão da persistência. Então, o que acontece? A gente tem que ter um banco de dados por serviço e, muitas vezes, a gente vai ter a persistência de forma duplicada entre os serviços. Isso quer dizer que eu vou ter uma tabela de clientes aqui dentro de orders, que tem todos os dados necessários para o cliente conseguir fazer um pedido. Então, o que o cliente precisa fazer um pedido? Preciso ter o endereço dele, vou mais macro, o e-mail... Preciso ter o documento dele... E eu preciso ter também dados do pagamento. Então, imagina que eu tenho que ter dados do cartão de crédito desse cliente para ele conseguir fazer o pedido. E aí, o que acontece? Na tabela de invoices, eu provavelmente também vou ter que ter uma tabela de clientes. Por quê? Porque para emitir nota fiscal, eu também preciso ter dados do cliente. Porém, eu talvez não preciso de todos os dados do cliente. Então, ao invés aqui na tabela de customers que está dentro de invoice, eu salvar exatamente todos os dados, porque daí eu teria que trafegar todos os dados por esse evento de comunicação, eu posso salvar somente os dados que são extremamente importantes serem salvos. E aí, eu posso ter aqui, por exemplo, para emitir nota fiscal, eu tenho que ter o address dele, O e-mail provavelmente também vai na nota fiscal, o documento também eu vou precisar para a nota fiscal. Agora, os dados de cartão eu não preciso trazer esses dados aqui para dentro, eu trago somente o que for realmente necessário. E aí, mesmo que a gente tenha a persistência distribuída, ou seja, cada serviço tem o seu próprio banco de dados, ainda assim, na grande maioria das vezes, vai existir um serviço que é, digamos, o detentor principal daquela informação, onde aquela informação foi criada. Então, imagina que quando o cliente faz um pedido, aí eu crio o registro nessa tabela de customers, ou seja, essa tabela de customers vai ser a primeira tabela entre todos os meus serviços que tem essa informação do meu customer. E depois, nas outras tabelas dos outros serviços, eu vou ter apenas uma cópia dos dados, uma referência para essa entidade principal. Então, é muito importante, é muito comum que geralmente eu guarde alguma referência dentro aqui do customer que me ajude a correlacionar este dado aqui com este dado que foi criado lá no primeiro momento. Nesse caso aqui, como a gente está falando de cliente, eu posso usar o documento, posso usar o e-mail, mas em alguns outros casos é comum que a gente guarde aqui, por exemplo, o ID do customer. E nesse caso aqui, na maioria das vezes, eu gosto também de prefixar o nome desse campo com o serviço que originou essa informação. Então, por exemplo, orders underline customer ID. Assim, fica fácil entender que este ID, que está sendo armazenado aqui no serviço de invoices, referencia o customer ID lá do meu serviço de orders. Em algum momento, se esse customer aqui for modificado, eu posso emitir um evento de orders para dentro de invoices, falando que o customer foi modificado, e aí ele vai poder ouvir essa informação e alterar os dados do customer aqui em tempo real. Se a gente for olhar aqui para dentro do código, trazendo um pouquinho mais aqui para o código em si, aqui dentro dos serviços de Analytics e URL Shortener, eu tenho aqui no meu esquema do banco de dados, se eu abrir o banco de dados e abrir o meu esquema, no URL Shortener, veja que eu salvo aqui as URLs. Então, quando o usuário cria uma URL, ele fala... redirecionar quando o usuário acessar aqui ó barra teste vou redirecionar ele para esta url aí eu tenho o número de cliques e tudo mais ah e se eu for no meu esquema do banco de dados lá do analytics a gente vai ver que eu tenho uma tabela de url creations né que eu salvo também a referência dessa url então eu tenho também uma persistência das urls no serviço de analytics e como eu falei antes quando o usuário cria uma url aqui dentro do serviço de url shorten eu emito um evento de URL criado, que é ouvido lá por dentro do meu sistema de analíticas, que faz a criação desse URL creations dentro do banco de dados, porque eu preciso desses dados aqui depois para anotar o número de cliques e tudo mais. Então, isso é muito importante a gente entender. E é claro, outra coisa que eu esqueci de falar na aula passada, eu deixei uma pastinha dentro desse projeto chamada docs, onde eu falo sobre cada um desses termos, desses fundamentos que eu estou trazendo aqui de forma mais aprofundada. Então, por exemplo, a gente falou sobre comunicação assíncrona no último vídeo. Então, se você abrir aqui esse doc, você vai ver que eu deixei uma documentação bem certinha de explicando como funciona todo esse fluxo de comunicação entre esses dois serviços utilizando o Kafka. E aqui, nesse caso, a gente está falando sobre persistência distribuída. Então, nesse caso de persistência distribuída, a gente também tem aqui uma documentação completinha, onde eu mostro que cada serviço tem o seu próprio banco de dados e a comunicação é feita através do Kafka para fazer o cadastro nesses bancos de dados. E é bem legal você dar uma lida aqui, porque eu deixei várias coisinhas... E aí, o que a gente falou aqui... Referential Integrity. Então, a gente usa Soft References, que é o que eu falei, ao invés de Foreign Keys, porque esse Order Customer ID que eu falei, que referencia o Customer ID lá do serviço de order, ele não pode ser uma Foreign Key, porque uma Foreign Key precisa ser checada, o registro precisa existir... Então, ela é só uma referência. Então, ela não é uma Foreign Key realmente. Então, ele mantém a integridade... lá com o customers, porém sem fazer uma correlação direta via banco de dados. Isso é bem legal, é bem desafiador, mas conforme a gente for entrando em alguns exemplos mais avançados, você vai entendendo o quanto é desafiador, mas é interessante ao mesmo tempo trabalhar com esse tipo de arquitetura.
