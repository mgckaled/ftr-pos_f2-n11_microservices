# Transcrição: 8. Saga Pattern

Um outro conceito, um pattern muito comum de ser utilizado quando você está utilizando microserviços é o Saga Pattern. Você talvez já tenha ouvido falar nesse Saga Pattern, ele é bem comum mesmo e tem aqui também, inclusive, documentado dentro do Microservices I.O. E o grande ponto que o Saga resolve é o seguinte... Imagina que... você tá fazendo uma requisição aqui vamos pegar esse exemplo de um e-commerce né que eu acho que é mais fácil visualizar imagina que você tá criando um pedido certo e aí ele cria o pedido e depois você avisa o sistema de notas fiscais para emitir uma nota fiscal para aquele pedido então você faz uma chamada assíncrona para o sistema de nota fiscal emitir aquele pedido só que imagina que esse pedido aqui essa nota fiscal, fale a geração. Mas fale de uma maneira que o pedido não poderia nem ter sido feito. Então, imagina que ele fale, por exemplo, dizendo que o CPF do usuário é inválido. Então, a gente precisaria, na verdade, voltar é cancelar o pedido dele então isso aqui é muito comum de acontecer dentro de micro serviços que é a gente precisar ter um rol back né ou dentro como é chamado dentro de micro serviços a par de compensação então uma ação ser gerada na chamada síncrona ser gerada e ela falhar e precisar haver uma compensação no serviço que originou aquela chamada. Só que isso pode escalar muito mais. Por exemplo, o serviço de pedidos pode chamar o serviço de nota fiscal, o serviço de nota fiscal pode chamar um outro serviço de consulta de pontuação no Serasa, por exemplo. E aí, esse serviço aqui falhar. E aí, eu tenho que desfazer a nota fiscal, depois desfazer o pedido do cliente. Então, olha só... Eu tenho uma compensação que tem que acontecer em dois serviços anteriores, que foram originados num primeiro serviço. E isso, o Saga resolve. O Saga, por mais que pareça algo difícil, na prática, ele não é muito diferente do que a gente já está acostumado. Então, imagina que a gente teria um evento, a order created, Certo? E aí, quando esse orderCreated fosse disparado, nós teríamos aqui um serviço de invoice que ele poderia devolver invoiceSuccess ou invoiceError. Se ele devolvesse invoiceError, o serviço de order passaria a ouvir o evento invoiceError e ele deletaria a ordem original ou cancelaria né então cancelar a ordem ou seja quando a gente implementa o saga né a gente basicamente toda a operação que a gente faz não toda né mas uma parte das operações que a gente faz assíncronas enviando mensagens assíncronas elas podem ter dois status elas podem começar a dar tanto sucesso quanto erro. Só que não adianta só sucesso ou erro, a gente precisa ter também qual que é o rollback, qual que é a compensação. Porque lembra que eu falei que o serviço de invoices pode acabar chamando também um terceiro serviço de Serasa, né? Então aqui ó... Vamos supor, ele gerou a nota, aí ele chama um terceiro serviço aqui, que é o serviço que envia PDF da nota. Só que aqui dá um erro que precisaria retornar também. Então, aqui eu também tenho que ter sucesso e tenho que ter um erro. E aí, o que acontece? Cada um desses serviços, imagina que aqui o envio do PDF deu um erro, um erro fatal que eu precisaria desfazer tudo que eu gerei até então. desfazer a invoice, desfazer o order. Nesse caso, eu teria que ter aqui dentro, configurado em cada um desses serviços aqui, o que vai acontecer com esse serviço para fazer um compensate, para fazer a compensação, para fazer o rollback. Você pode chamar como você preferir. Então, se deu erro na geração do PDF, eu preciso fazer um rollback na nota fiscal e preciso fazer um rollback dentro da order. Então, é como se a gente colocasse todo esse fluxo aqui dentro dentro de uma transaction do banco de dados, onde cada operação, depois que ela é feita, caso ela dê o erro, as demais que aconteceram antes precisam ser desfeitas. E é assim que funciona o Saga. Então, se a gente for ver aqui dentro do serviço, o RLE Shortener... Ou melhor, vamos lá no serviço de autenticação aqui. Então, aqui no serviço de autenticação, quando eu estou na rota de apagar um usuário... Quando eu apago um usuário, eu tenho que apagar também todas as URLs que ele gerou, todas as URLs encurtadas que ele gerou, que estão em outro serviço... E tenho que apagar também os analytics dessas URLs. Então, olha só... Quando eu requisito aqui o delete do usuário, eu busco se o usuário existe e eu criei aqui um serviço de orquestração... que é quem vai gerenciar tudo isso aqui, o orchestrator... E ele vai chamar esse request user deletion aqui. O que esse carinha aqui vai fazer? Ele vai chamar aqui o meu orchestrator que eu criei, que é um centralizador, digamos, dos sagas, enviando esse evento de user deletion aqui dentro. E aí, se eu for entrar aqui dentro de Kafka, saga step consumer... Deixa eu lembrar aqui onde é que está a minha configuração... Aqui. Eu tenho basicamente... duas funções, handleDeleteUserAccount, então essa função aqui ela vai ser responsável por deletar a conta do usuário e essa função aqui ela vai ser o compensation, ela vai ser o rollback Então, para toda ação que acontece, eu tenho que ter uma ação que volta atrás. Então, olha só... Eu removo a remoção, eu desfaço a remoção da conta dele. Por isso que eu não apago do banco de dados. Eu só faço um soft delete aqui e aqui, no caso, eu tiro esse soft delete. Então, eu boto delete at null e deixo a conta dele ativa novamente. E aqui embaixo, eu basicamente configuro para quê? Quando... aconteça o delete user account, eu faço o delete. Senão, eu faço aqui embaixo o restore, que é a compensação. E aí, o que acontece? Nos outros serviços, por exemplo, no RL Shortener, eu também ouço aqui esse evento do Kafka e aí eu tenho o handle delete user urls e o handle restore user urls e aí ó quando acontece a remoção eu tento apagar quando precisar acontecer a compensação o restore eu tento fazer um restore dessas urls que nada mais é do que como eu falei antes ali né um soft delete né então eu altero as urls aqui o delete at pra nu de volta né então volto as urls do usuário então basicamente isso acontece em cima de um orquestrador que é quem gerencia isso o orquestrador nada mais é do que um serviço que tem no seu banco de dados quais sagas aconteceram, quais requisições estão acontecendo, por exemplo, a deletar usuário. E ele gerencia o envio dessas mensagens para dentro dos outros serviços. Então, eu tenho aqui, por exemplo, o User Deletion, que é o meu evento. Então, olha só... Ele basicamente cria um workflow, que é um passo a passo. Então, ele fala... O Saga de User Deletion, o Saga nada mais é do que a representação de um evento que vai acontecer dividido em múltiplos passos, cada passo em um serviço diferente... Então, olha só... Quando acontecer o User Deletion, ele vai percorrer esses três caminhos. O primeiro passo é ele vai deletar as URLs dos usuários. Para as URLs serem deletadas, ele precisa chamar o serviço URLShortener, enviando o tópico URLShortener.deleteUserUrls e caso isso aqui fale, a compensação aqui agora é restaurar os UserUrls. Perfeito. O próximo passo é deletar tudo que tem relacionado aos UserAnalytics, então ele vai disparar esse tópico aqui no Kafka. E caso ele falhe aqui, ele vai restaurar o User Analytics, porém ele vai restaurar também as URLs, ou seja, toda a compensação ele faz de todos os passos que já tinham sido percorridos até ali. E ele sabe os passos que já tinham sido percorridos até ali, porque eu tenho bancos de dados aqui para os steps, anotando cada passo que foi concluído. Por último, eu tenho... Cadê? Perdi o meu orquestrador... Aqui! Por último, eu tenho o último passo que aí sim é deletar a conta do usuário. Então, se eu conseguir deletar as URLs dele, conseguir deletar o Analytics dele, finalmente eu vou deletar a conta dele. E aí, caso dê algum erro aqui, eu vou compensar todos esses passos, ou seja, eu vou voltar as URLs, vou voltar os Analytics e vou voltar a conta dele. Todo esse Orchestrator aqui eu construí do zero, mas se você estiver usando um framework, por exemplo, o NestJS, ele já tem um orquestrador automático. Então, o próprio NestJS Ele já tem... Nossa, eu odeio quando ele faz a transcrição automática. Original. Então, ele tem aqui o padrão de saga, onde você consegue configurar essa parte de sagas de forma mais automatizada. O Node hoje, sendo bem sincero, Quando você vai trabalhar com microserviços, geralmente o Node não é muito usado para orquestrador de sagas, porque ele não é uma ferramenta que tem bibliotecas disponíveis muito avançadas para isso. Geralmente é usado Java, utilizado Go nesses casos. O Node geralmente é usado para construção dos serviços, digamos, dos pontos finais e não dos orquestradores de sagas e tudo mais. Então, até porque, como você viu, tem que configurar muita coisa na mão para fazer isso. Mas o mais importante aqui, como a gente está passando, é a gente entender os conceitos. E aqui também eu deixei uma documentação para você ver como esse Saga funciona na prática. Aqui ele ficou um pouquinho embaralhado, mas aqui com esse diagrama sequencial dá para entender um pouquinho mais. Então, o usuário pede para deletar e ele começa a orquestração dos tópicos. Então, ele processa, ele envia para o orquestrador e o orquestrador começa a enviar para cada um dos serviços o URL para fazer um Soft Delete, depois para o Analytics fazer um Soft Delete, E aí, caso dê algum problema, ele faz a compensação restaurando esses dados no banco de dados. Aqui tem um pouquinho mais de documentação caso você queira dar uma lida para entender como é que funciona no banco de dados e tudo mais.
