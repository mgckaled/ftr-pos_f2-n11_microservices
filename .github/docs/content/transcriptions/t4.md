# Transcrição: 4. Autenticação em Microsserviços

Outro desafio que a gente tem muito comum dentro de serviços é a autenticação, porque imagina que a gente tenha rotas HTTP no serviço de encurtamento, tem rota HTTP no serviço de analytics, então imagina que... Por exemplo, para o usuário criar uma URL, ele tem que estar autenticado. Para o usuário buscar no serviço de Analytics o count de cliques de uma URL, ele tem que estar autenticado. E não faz sentido o usuário se autenticar em dois serviços diferentes. Então, o que geralmente a gente faz numa arquitetura de microserviços, nós temos um serviço especializado em autenticação. Então, ele fica guardadinho aqui no canto. Esse serviço de autenticação aqui é quem faz a geração dos tokens ou das sessões, depende muito do algoritmo que você está usando para... para autenticação, mas imagina que seja um JWT. Então, esse serviço de autenticação é quem cria o JWT. Os outros serviços aqui não precisam criar o JWT, eles precisam apenas validar que esse JWT é válido, que ele realmente foi gerado dentro da stack de serviços que a gente tem. Para isso, a gente tem duas alternativas. O que acontece? Quando a gente tem JWT, a gente tem os algoritmos de geração de token e aí nós temos algoritmos de geração simétrico de chaves simétricas e assimétricas né o que acontece quando a gente usa um algoritmo de chave simétrica geralmente começa com hs hs256 por exemplo que é o algoritmo tradicional nós temos uma única chave um único secret que é gerado que é usado tanto para geração de chaves. Então, esse secret seria usado, estaria nas variáveis ambiente do serviço de auth, aqui por exemplo, para conseguir gerar JWTs. E ele estaria também nas variáveis ambiente dos outros serviços, do shortener e do analytics, para que esses serviços conseguissem validar que esse... que a URL está autenticada, certo? Só que isso não é muito legal, porque esse secret, como ele pode ser usado para criar tokens, ele é uma informação bem sensível. Então, não é muito legal a gente ficar armazenando essa informação em vários locais. Até também um dia, se essa variável acabar vazando, cara, eu vou ter que substituir ela. Imagina que eu tenha 500 serviços, eu vou ter que substituir ela em variável ambiente de 500 serviços. Então, isso não é muito legal. Então, o que a gente geralmente faz é utilizar um algoritmo de chave assimétrica. E aí, a gente geralmente começa com R. Então, RS256, por exemplo, RS512. E o que acontece? Nesses algoritmos, nós não temos apenas uma chave secret, nós temos uma chave privada e uma pública. Isso aí é muito utilizado para muitos padrões de comunicação, para SSH, até para aqueles... certificado digital, se você já teve, para emissão de nota fiscal, para assinatura online, muita coisa. O que acontece? Nesses algoritmos, a chave privada é a única que pode escrever novas informações ou escrever novos tokens. Então, o serviço de auth é o único que vai ter acesso à chave privada. Enquanto a chave pública, como o próprio nome já diz, ela pode estar pública, disponível em todos os outros serviços, até o front-end pode ter acesso. Porque ela não pode ser usada para a criação de novos tokens, ela sempre vai ser usada para apenas decode, apenas validação se aquele token foi gerado por esta chave privada ou não, se é um token válido ou não. Então, a gente distribui essa chave pública entre todos os serviços. Mas a gente continua com o mesmo problema que eu citei antes, de a gente ter que repetir essa chave aqui em todos os serviços. E um dia, se ela precisar mudar, eu teria que alterar e fazer um deploy de todos os serviços do zero. Por isso, geralmente, a gente usa uma estratégia de JWA, JWKS, que é uma estratégia que permite a gente ter um endpoint. Então, imagina que eu tenho um endpoint chamado JWT, aqui no serviço de autenticação, que ele retorna a chave pública. Então, o que acontece? Esses serviços aqui, Shortener e Analytics, para eles conseguirem fazer um decode do token, a validação do token, eles chamam o endpoint do JWT, que retorna a chave pública e aí eles usam essa chave pública para fazer a validação, o decode do token. Se a gente for entrar no código para entender um pouquinho como que isso funciona, e novamente eu tenho aqui uma documentação de como que isso funciona, o serviço de auth que lida com registro, com autenticação, então é o único local para tudo isso, a gente usa o JWT. E aí ele fala aqui do algoritmo que eu estou usando, que é o Argon para hash de senhas, mas não é mais o importante. Então, basicamente, o que acontece? Fluxo de autorização. O cliente faz uma requisição com o JWT, logo a gente vai falar sobre o Kong, mas imagina que ele faz a requisição para qualquer... Ou seja, o nosso serviço aqui busca o JWKS, que eu falei, busca as chaves, que retorna a chave pública, Aí ele valida o JWT, se for permitido, então ele permite o cliente fazer o restante da operação, senão ele não permite. E aí, aqui a gente pode entender como que isso funciona, basicamente vindo aqui no serviço de autenticação. A gente vai ver aqui dentro do .env dele, eu tenho o JWT Secret aqui dentro, E aqui no source, nós temos uma rota que é a getJWKS, que ela chama esse serviço aqui, que retorna a nossa chave. E aqui eu estou usando uma chave simétrica, usando o algoritmo hs256, apenas em desenvolvimento. Em produção, a gente usa geralmente uma chave assimétrica. E aí, aqui o meu serviço, por exemplo, de Analytics, quando ele vai fazer a autenticação... Então, vamos entrar aqui num server da vida... Deixa eu pegar aqui as minhas rotas... Aqui, Registered Routes... quando eu preciso validar a autenticação do usuário. Aqui eu não vou conseguir mostrar, porque ela depende de uma outra explicação que eu vou dar na próxima aula. Então, a gente entra nessa parte de como o serviço valida a autenticação na próxima aula. Mas é basicamente com esse fluxo aqui de chave privada e chave pública que eu te mostrei. Isso é bem interessante.
