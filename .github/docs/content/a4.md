<!-- markdownlint-disable -->

# Autenticação em Microsserviços

## Resumo Executivo

A autenticação em arquiteturas de microsserviços representa desafio fundamental que exige abordagens distintas daquelas empregadas em sistemas monolíticos. Em contexto distribuído onde múltiplos serviços independentes oferecem rotas HTTP que demandam proteção, não é viável nem seguro implementar mecanismos de autenticação redundantes em cada serviço individual. A solução arquitetural estabelecida consiste em centralizar responsabilidade de autenticação em serviço especializado dedicado, enquanto demais serviços assumem exclusivamente papel de validação de credenciais já emitidas. Este documento explora fundamentos teóricos e práticos da autenticação distribuída, com ênfase em JSON Web Tokens como mecanismo predominante, algoritmos de assinatura simétrica e assimétrica, padrões de distribuição de chaves públicas através de JWKS, e estratégias para manutenção de segurança sem proliferação de segredos sensíveis na infraestrutura.

## Introdução e Conceitos

### Desafio da Autenticação Distribuída

Em arquitetura monolítica tradicional, autenticação constitui preocupação centralizada onde aplicação única gerencia sessões de usuários, valida credenciais e mantém estado de autenticação através de mecanismos como sessões em memória, cookies ou tokens armazenados centralmente. Transição para microsserviços fragmenta este cenário, introduzindo múltiplos pontos de entrada HTTP distribuídos geograficamente e operacionalmente independentes. Considere sistema de encurtamento de URLs composto por serviço de Encurtamento responsável por criar URLs curtas e serviço de Analytics encarregado de processar estatísticas de acessos. Ambos expõem rotas HTTP que requerem autenticação: criação de URL curta demanda usuário autenticado, assim como consulta de métricas analíticas. Solicitar que usuário autentique-se separadamente em cada serviço contradiz princípios fundamentais de experiência de usuário e segurança, além de introduzir complexidade desnecessária na gestão de credenciais.

### Serviço de Autenticação Centralizado

Padrão arquitetural estabelecido consiste em extrair responsabilidade de autenticação para serviço dedicado especializado, frequentemente denominado Auth Service ou Identity Provider. Este serviço assume responsabilidades críticas incluindo registro de novos usuários, validação de credenciais durante processo de login, geração de tokens de autenticação, e potencialmente gerenciamento de refresh tokens para renovação de sessões. Serviços de domínio como Shortener e Analytics não participam do processo de autenticação propriamente dito, assumindo exclusivamente papel de validação: ao receberem requisição contendo token de autenticação, verificam se este token foi legitimamente emitido pelo Auth Service e se permanece válido, extraindo informações de identidade do usuário necessárias para autorização e auditoria.

### JSON Web Tokens como Padrão

JSON Web Token emergiu como padrão de facto para autenticação em sistemas distribuídos, especificado formalmente na RFC 7519. JWT representa token autocontido que encapsula claims sobre entidade autenticada em formato JSON, codificado em Base64URL e assinado criptograficamente para garantir integridade e autenticidade. Estrutura de JWT compreende três componentes separados por pontos: Header especificando algoritmo de assinatura e tipo de token, Payload contendo claims como identificador de usuário, timestamp de expiração e permissões, e Signature garantindo que token não foi adulterado após emissão. Natureza autocontida de JWT elimina necessidade de consultar banco de dados ou serviço externo para validar autenticação em cada requisição, pois todas informações necessárias estão encapsuladas no próprio token, desde que assinatura criptográfica possa ser verificada.

## Algoritmos de Assinatura: Simétricos versus Assimétricos

### Algoritmos Simétricos: HS256, HS384, HS512

Algoritmos de assinatura simétrica utilizam chave secreta única compartilhada tanto para criação quanto para validação de tokens. HMAC-SHA256, comumente referenciado como HS256, constitui algoritmo simétrico mais amplamente utilizado para JWTs, empregando função hash SHA-256 combinada com chave secreta para gerar assinatura. Processo de geração consiste em concatenar header codificado e payload codificado, aplicar função HMAC-SHA256 utilizando secret como chave, e anexar resultado como terceiro componente do JWT. Validação segue procedimento inverso: serviço receptor reconstrói assinatura utilizando mesma chave secreta e compara com assinatura presente no token, confirmando autenticidade se corresponderem.

Implementação típica em TypeScript utilizando biblioteca jsonwebtoken demonstra simplicidade do algoritmo simétrico:

```typescript
import jwt from 'jsonwebtoken';

const SECRET_KEY = 'minha-chave-secreta-super-segura';

// Geração de token no Auth Service
const payload = {
  userId: 12345,
  email: 'usuario@exemplo.com',
  role: 'admin'
};

const token = jwt.sign(payload, SECRET_KEY, {
  algorithm: 'HS256',
  expiresIn: '1h',
  issuer: 'auth-service',
  audience: 'api-services'
});

console.log('Token gerado:', token);

// Validação de token em serviços de domínio
try {
  const decoded = jwt.verify(token, SECRET_KEY, {
    algorithms: ['HS256'],
    issuer: 'auth-service',
    audience: 'api-services'
  });

  console.log('Token válido:', decoded);
  console.log('User ID:', decoded.userId);
} catch (error) {
  console.error('Token inválido:', error.message);
}
```

### Problema de Proliferação de Segredos

Embora algoritmos simétricos ofereçam implementação direta e performance superior, introduzem desafio crítico de segurança em arquiteturas distribuídas: proliferação de segredos. Para que Auth Service gere tokens e serviços Shortener e Analytics os validem, todos três serviços necessitam acesso à mesma chave secreta armazenada em suas variáveis de ambiente. Esta distribuição multiplica superfície de ataque: comprometimento de qualquer serviço expõe chave mestra capaz de forjar tokens válidos para sistema inteiro. Rotação de chaves, prática fundamental de segurança recomendada periodicamente ou após suspeita de comprometimento, torna-se operacionalmente complexa exigindo atualização coordenada de variáveis de ambiente e redeploy sincronizado de potencialmente centenas de serviços. Em organizações com dezenas ou centenas de microsserviços, este problema amplifica-se exponencialmente, tornando gestão de chaves simétricas insustentável.

### Algoritmos Assimétricos: RS256, RS384, RS512

Criptografia de chave pública resolve fundamentalmente problema de proliferação através de par de chaves assimétricas: chave privada utilizada exclusivamente para geração de assinaturas, e chave pública correspondente empregada para validação. RS256 implementa este paradigma utilizando algoritmo RSA com SHA-256, onde Auth Service mantém custódia exclusiva da chave privada em formato PEM, utilizando-a para assinar tokens durante processo de login. Chave pública correspondente, matematicamente relacionada mas computacionalmente impossível de reverter para obter chave privada, distribui-se livremente para todos serviços que necessitam validar tokens. Propriedade fundamental garante que assinatura criada com chave privada somente pode ser verificada com chave pública correspondente, enquanto chave pública não possui capacidade de gerar novas assinaturas válidas.

Geração de par de chaves RSA utilizando OpenSSL:

```bash
# Gerar chave privada RSA de 2048 bits
openssl genrsa -out private-key.pem 2048

# Extrair chave pública correspondente
openssl rsa -in private-key.pem -pubout -out public-key.pem
```

Implementação em TypeScript demonstrando assinatura assimétrica:

```typescript
import jwt from 'jsonwebtoken';
import fs from 'fs';

// Auth Service: assinar com chave privada
const privateKey = fs.readFileSync('private-key.pem', 'utf8');

const payload = {
  userId: 12345,
  email: 'usuario@exemplo.com',
  permissions: ['read', 'write']
};

const token = jwt.sign(payload, privateKey, {
  algorithm: 'RS256',
  expiresIn: '2h',
  issuer: 'auth-service',
  subject: 'user-authentication'
});

console.log('Token RS256 gerado:', token);

// Serviços de Domínio: validar com chave pública
const publicKey = fs.readFileSync('public-key.pem', 'utf8');

try {
  const decoded = jwt.verify(token, publicKey, {
    algorithms: ['RS256'],
    issuer: 'auth-service'
  });

  console.log('Token verificado com sucesso:', decoded);
  console.log('Permissões do usuário:', decoded.permissions);
} catch (error) {
  if (error.name === 'TokenExpiredError') {
    console.error('Token expirado:', error.expiredAt);
  } else if (error.name === 'JsonWebTokenError') {
    console.error('Token inválido:', error.message);
  }
}
```

### Vantagens de Chaves Assimétricas

Separação entre capacidade de assinatura e validação oferece benefícios substanciais para segurança e operação de sistemas distribuídos. Chave privada permanece exclusivamente no Auth Service, preferencialmente armazenada em Hardware Security Module ou serviço de gestão de segredos como HashiCorp Vault, AWS Secrets Manager ou Azure Key Vault, nunca sendo exposta a serviços de domínio. Chave pública, por natureza não-sensível, pode ser distribuída livremente através de variáveis de ambiente, arquivos de configuração ou endpoints públicos sem comprometer segurança do sistema. Comprometimento de serviço de domínio expõe apenas chave pública, insuficiente para forjar novos tokens, limitando impacto de segurança. Rotação de chaves simplifica-se consideravelmente: novo par de chaves é gerado no Auth Service, chave pública atualizada distribui-se gradualmente aos serviços consumidores, enquanto Auth Service temporariamente aceita validação com ambas chaves antigas e novas durante período de transição, eliminando necessidade de redeploy coordenado.

## JSON Web Key Set: Distribuição Dinâmica de Chaves Públicas

### Limitações da Distribuição Estática

Mesmo com chaves assimétricas, distribuir chaves públicas através de variáveis de ambiente em todos serviços perpetua problema operacional: rotação ainda requer atualização de configuração e redeploy de cada serviço consumidor. Em organizações com centenas de microsserviços, este processo torna-se gargalo operacional significativo, introduzindo janela de vulnerabilidade onde serviços não atualizados rejeitam tokens válidos gerados com novo par de chaves. Adicionalmente, estratégias avançadas de segurança frequentemente empregam múltiplas chaves simultâneas, rotacionando-as periodicamente enquanto mantêm chaves anteriores válidas durante período de graça, permitindo que tokens emitidos próximos à rotação permaneçam válidos até expiração natural.

### Especificação JWKS: RFC 7517

JSON Web Key Set, especificado na RFC 7517, estabelece formato padronizado para publicar chaves públicas através de endpoint HTTP acessível publicamente. JWKS consiste em objeto JSON contendo array de chaves no atributo keys, onde cada chave inclui metadados como kty especificando tipo de chave, kid fornecendo identificador único para seleção durante validação, use indicando propósito, alg declarando algoritmo, e componentes matemáticos da chave pública como n e e para RSA. Auth Service expõe endpoint tipicamente localizado em /.well-known/jwks.json retornando conjunto atual de chaves públicas válidas. Header de tokens JWT inclui campo kid correspondendo a identificador de chave utilizada para assinatura, permitindo que validador selecione chave apropriada de conjunto publicado.

Estrutura típica de resposta JWKS:

```json
{
  "keys": [
    {
      "kty": "RSA",
      "kid": "auth-key-2024-01",
      "use": "sig",
      "alg": "RS256",
      "n": "xGOr-H7A-qZ...base64-modulus",
      "e": "AQAB"
    },
    {
      "kty": "RSA",
      "kid": "auth-key-2023-12",
      "use": "sig",
      "alg": "RS256",
      "n": "yH2s-K8B-rA...base64-modulus",
      "e": "AQAB"
    }
  ]
}
```

### Implementação de Endpoint JWKS

Auth Service implementa endpoint dedicado retornando JWKS construído a partir de chave privada em memória ou HSM. Biblioteca jwks-rsa simplifica conversão de chaves PEM para formato JWK padronizado. Implementação demonstrativa em TypeScript utilizando Express:

```typescript
import express from 'express';
import jwt from 'jsonwebtoken';
import fs from 'fs';
import { exportJWK } from 'jose';

const app = express();
const privateKey = fs.readFileSync('private-key.pem', 'utf8');
const publicKey = fs.readFileSync('public-key.pem', 'utf8');

// Endpoint JWKS
app.get('/.well-known/jwks.json', async (req, res) => {
  try {
    const jwk = await exportJWK(publicKey);

    res.json({
      keys: [
        {
          ...jwk,
          kid: 'auth-key-2024-01',
          use: 'sig',
          alg: 'RS256'
        }
      ]
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to generate JWKS' });
  }
});

// Endpoint de autenticação
app.post('/auth/login', (req, res) => {
  const { email, password } = req.body;

  // Validação de credenciais omitida para brevidade

  const token = jwt.sign(
    {
      userId: 12345,
      email: email,
      role: 'user'
    },
    privateKey,
    {
      algorithm: 'RS256',
      expiresIn: '1h',
      issuer: 'auth-service',
      keyid: 'auth-key-2024-01'
    }
  );

  res.json({ token });
});

app.listen(3000, () => {
  console.log('Auth Service running on port 3000');
});
```

### Validação Dinâmica com JWKS

Serviços consumidores utilizam biblioteca jwks-rsa para buscar dinamicamente chave pública apropriada do endpoint JWKS baseando-se em kid presente no header do token. Esta abordagem elimina necessidade de distribuir chaves através de variáveis de ambiente, permitindo rotação transparente onde Auth Service adiciona nova chave ao JWKS enquanto mantém chaves anteriores válidas temporariamente. Implementação em serviço Shortener:

```typescript
import express from 'express';
import jwt from 'jsonwebtoken';
import jwksClient from 'jwks-rsa';

const app = express();

// Cliente JWKS configurado para buscar chaves do Auth Service
const client = jwksClient({
  jwksUri: 'http://auth-service:3000/.well-known/jwks.json',
  cache: true,
  cacheMaxAge: 600000, // 10 minutos
  rateLimit: true,
  jwksRequestsPerMinute: 10
});

// Função para obter chave pública baseada no kid
function getKey(header: jwt.JwtHeader, callback: jwt.SigningKeyCallback) {
  client.getSigningKey(header.kid, (err, key) => {
    if (err) {
      return callback(err);
    }
    const signingKey = key?.getPublicKey();
    callback(null, signingKey);
  });
}

// Middleware de autenticação
function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Token not provided' });
  }

  jwt.verify(token, getKey, {
    algorithms: ['RS256'],
    issuer: 'auth-service'
  }, (err, decoded) => {
    if (err) {
      if (err.name === 'TokenExpiredError') {
        return res.status(401).json({ error: 'Token expired' });
      }
      return res.status(403).json({ error: 'Invalid token' });
    }

    req.user = decoded;
    next();
  });
}

// Rota protegida
app.post('/shorten', authenticateToken, (req, res) => {
  const { url } = req.body;
  const userId = req.user.userId;

  console.log(`User ${userId} creating short URL for: ${url}`);

  // Lógica de encurtamento omitida

  res.json({
    shortUrl: 'https://short.url/abc123',
    createdBy: userId
  });
});

app.listen(4000, () => {
  console.log('Shortener Service running on port 4000');
});
```

### Estratégia de Cache e Performance

Buscar chave pública do endpoint JWKS em cada validação de token introduziria latência inaceitável e carga desnecessária no Auth Service. Biblioteca jwks-rsa implementa cache inteligente armazenando chaves públicas em memória após primeira recuperação, com time-to-live configurável tipicamente entre 10 minutos e 1 hora. Cache invalida-se automaticamente ao encontrar kid desconhecido no token, forçando nova busca ao JWKS e atualizando cache com chaves recém-adicionadas. Rate limiting protege Auth Service contra ataques de negação de serviço através de validações massivas com kids inexistentes. Esta arquitetura permite que Auth Service rotacione chaves adicionando novo par ao JWKS: próximos tokens serão assinados com nova chave, e serviços consumidores automaticamente buscarão nova chave pública ao encontrarem kid desconhecido, sem qualquer intervenção operacional ou redeploy.

## Fluxo Completo de Autenticação

### Registro e Login

Usuário inicia interação registrando-se no sistema através de requisição POST ao endpoint /auth/register do Auth Service, fornecendo credenciais como email e senha. Auth Service aplica função de hash criptográfico forte como Argon2, bcrypt ou PBKDF2 à senha antes de armazená-la em banco de dados, nunca persistindo senhas em texto plano. Argon2 emerge como algoritmo recomendado atualmente por resistência superior a ataques de força bruta utilizando GPUs e ASICs, tendo vencido Password Hashing Competition em 2015. Implementação demonstrativa:

```typescript
import argon2 from 'argon2';
import { randomBytes } from 'crypto';

// Registro de usuário
async function registerUser(email: string, password: string) {
  const salt = randomBytes(32);
  const hashedPassword = await argon2.hash(password, {
    type: argon2.argon2id,
    salt: salt,
    memoryCost: 65536, // 64 MB
    timeCost: 3,
    parallelism: 4
  });

  // Persistir em banco de dados
  await database.users.create({
    email: email,
    passwordHash: hashedPassword,
    createdAt: new Date()
  });

  return { success: true };
}

// Login de usuário
async function loginUser(email: string, password: string) {
  const user = await database.users.findOne({ email });

  if (!user) {
    throw new Error('Invalid credentials');
  }

  const validPassword = await argon2.verify(user.passwordHash, password);

  if (!validPassword) {
    throw new Error('Invalid credentials');
  }

  const token = jwt.sign(
    {
      userId: user.id,
      email: user.email,
      role: user.role
    },
    privateKey,
    {
      algorithm: 'RS256',
      expiresIn: '1h',
      issuer: 'auth-service',
      keyid: 'auth-key-2024-01'
    }
  );

  return { token };
}
```

### Requisição Autenticada a Serviço de Domínio

Cliente obtém token JWT do Auth Service durante login e o inclui em header Authorization de requisições subsequentes a serviços de domínio utilizando esquema Bearer padrão: Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImF1dGgta2V5LTIwMjQtMDEifQ.... Serviço de domínio como Shortener extrai token do header, decodifica header JWT para identificar kid, busca chave pública correspondente do cache JWKS ou do endpoint se ausente, e valida assinatura criptográfica. Validação bem-sucedida resulta em decodificação de payload contendo claims do usuário, disponibilizados para lógica de negócio através de objeto req.user. Validação falha devido a assinatura inválida, token expirado ou kid desconhecido resulta em resposta HTTP 401 Unauthorized ou 403 Forbidden.

### Fluxo End-to-End

```
┌─────────┐                 ┌──────────────┐                ┌───────────┐                ┌───────────┐
│ Cliente │                 │ Auth Service │                │ Shortener │                │ Analytics │
└────┬────┘                 └──────┬───────┘                └─────┬─────┘                └─────┬─────┘
     │                             │                              │                            │
     │ POST /auth/register         │                              │                            │
     ├────────────────────────────>│                              │                            │
     │                             │ Hash senha com Argon2        │                            │
     │                             │ Persistir usuário            │                            │
     │ 201 Created                 │                              │                            │
     │<────────────────────────────┤                              │                            │
     │                             │                              │                            │
     │ POST /auth/login            │                              │                            │
     ├────────────────────────────>│                              │                            │
     │                             │ Validar credenciais          │                            │
     │                             │ Gerar JWT com chave privada  │                            │
     │ { token: "eyJ..." }         │                              │                            │
     │<────────────────────────────┤                              │                            │
     │                             │                              │                            │
     │ POST /shorten                                              │                            │
     │ Authorization: Bearer eyJ...                               │                            │
     ├───────────────────────────────────────────────────────────>│                            │
     │                                                            │ GET /.well-known/jwks.json │
     │                                                            ├───────────────────────────>│
     │                                                            │ { keys: [...] }            │
     │                                                            │<───────────────────────────┤
     │                                                            │ Validar JWT com chave pública
     │                                                            │ Extrair userId do payload  │
     │                                                            │ Processar lógica de negócio│
     │ { shortUrl: "..." }                                        │                            │
     │<───────────────────────────────────────────────────────────┤                            │
     │                                                            │                            │
```

## Padrões Avançados de Autenticação

### Refresh Tokens e Renovação de Sessão

Tokens JWT com expiração curta, tipicamente entre 15 minutos e 1 hora, minimizam janela de vulnerabilidade caso token seja comprometido, pois atacante possui tempo limitado para utilizá-lo maliciosamente. Entretanto, forçar usuário a autenticar-se novamente após expiração prejudica experiência de uso. Padrão estabelecido utiliza Refresh Tokens: tokens de longa duração, geralmente válidos por 7 a 30 dias, armazenados de forma segura no cliente e utilizados exclusivamente para obter novos Access Tokens sem reapresentar credenciais. Auth Service mantém registro de Refresh Tokens emitidos em banco de dados, permitindo revogação imediata mediante suspeita de comprometimento, logout explícito ou detecção de uso anômalo. Access Tokens permanecem stateless validados apenas criptograficamente, enquanto Refresh Tokens requerem consulta a banco de dados durante renovação.

```typescript
// Estrutura de tokens
interface TokenPair {
  accessToken: string;  // JWT de curta duração, stateless
  refreshToken: string; // Token opaco de longa duração, stateful
}

// Login retorna par de tokens
async function loginUser(email: string, password: string): Promise<TokenPair> {
  // Validação de credenciais omitida

  const accessToken = jwt.sign(
    { userId: user.id, email: user.email },
    privateKey,
    { algorithm: 'RS256', expiresIn: '15m', keyid: 'auth-key-2024-01' }
  );

  const refreshToken = randomBytes(32).toString('hex');

  await database.refreshTokens.create({
    token: refreshToken,
    userId: user.id,
    expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 dias
    createdAt: new Date()
  });

  return { accessToken, refreshToken };
}

// Renovação de access token
async function refreshAccessToken(refreshToken: string): Promise<TokenPair> {
  const storedToken = await database.refreshTokens.findOne({
    token: refreshToken,
    expiresAt: { $gt: new Date() }
  });

  if (!storedToken) {
    throw new Error('Invalid or expired refresh token');
  }

  const user = await database.users.findById(storedToken.userId);

  const newAccessToken = jwt.sign(
    { userId: user.id, email: user.email },
    privateKey,
    { algorithm: 'RS256', expiresIn: '15m', keyid: 'auth-key-2024-01' }
  );

  // Opcional: rotacionar refresh token
  const newRefreshToken = randomBytes(32).toString('hex');
  await database.refreshTokens.deleteOne({ token: refreshToken });
  await database.refreshTokens.create({
    token: newRefreshToken,
    userId: user.id,
    expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
    createdAt: new Date()
  });

  return { accessToken: newAccessToken, refreshToken: newRefreshToken };
}
```

### OAuth 2.0 e OpenID Connect

OAuth 2.0, especificado na RFC 6749, estabelece framework de autorização permitindo que aplicações obtenham acesso limitado a recursos de usuário em serviço terceiro sem expor credenciais. Fluxo Authorization Code constitui padrão mais seguro para aplicações web, onde usuário é redirecionado ao Authorization Server, autentica-se e consente escopo de permissões, recebendo código de autorização efêmero que aplicação troca por Access Token através de requisição autenticada com Client Secret. OpenID Connect adiciona camada de autenticação sobre OAuth 2.0, introduzindo ID Token como JWT contendo informações de identidade do usuário, permitindo que aplicações conheçam quem está autenticado além de apenas ter autorização para acessar recursos.

### Mutual TLS para Autenticação Service-to-Service

Comunicação entre microsserviços internos frequentemente requer autenticação mútua onde ambos cliente e servidor verificam identidade através de certificados X.509. Mutual TLS estabelece canal criptografado onde serviço cliente apresenta certificado assinado por Certificate Authority interna confiável durante handshake TLS, permitindo que servidor valide identidade do chamador antes de processar requisição. Service Mesh como Istio automatiza emissão, rotação e validação de certificados mTLS, estabelecendo zero-trust network onde toda comunicação inter-serviços é autenticada e criptografada por padrão, eliminando necessidade de propagação de tokens JWT entre serviços internos.

## Segurança e Melhores Práticas

### Validação Rigorosa de Claims

Validar exclusivamente assinatura criptográfica de JWT não garante segurança adequada. Claims como exp (expiration time), nbf (not before), iss (issuer) e aud (audience) devem ser validados rigorosamente para prevenir replay attacks e uso indevido de tokens. Especificar array algorithms durante validação previne algoritmo confusion attacks onde atacante modifica header para algoritmo none ou downgrade para HS256, potencialmente aceitando tokens não-assinados ou assinados com chave pública como secret simétrico.

```typescript
const validationOptions: jwt.VerifyOptions = {
  algorithms: ['RS256', 'RS384', 'RS512'], // Apenas algoritmos assimétricos
  issuer: 'auth-service',                   // Validar emissor esperado
  audience: 'api-services',                 // Validar audiência esperada
  clockTolerance: 30,                       // 30 segundos de tolerância para clock skew
  maxAge: '2h'                              // Idade máxima do token
};

jwt.verify(token, getKey, validationOptions, (err, decoded) => {
  if (err) {
    // Tratamento de erro apropriado
  }
  // Token válido
});
```

### Proteção de Chaves Privadas

Chave privada constitui ativo mais crítico de sistema de autenticação: compromisso permite geração de tokens válidos arbitrários, comprometendo sistema inteiro. Armazenar chave privada em arquivo no sistema de arquivos do Auth Service representa risco substancial. Soluções de gestão de segredos como HashiCorp Vault, AWS Secrets Manager, Azure Key Vault ou Google Secret Manager fornecem armazenamento criptografado, controle de acesso granular, auditoria completa e rotação automatizada. Hardware Security Modules oferecem proteção máxima mantendo chaves em dispositivo físico resistente a extração, executando operações criptográficas internamente sem expor material de chave.

### Rate Limiting e Throttling

Endpoints de autenticação constituem alvo primário de ataques de força bruta e credential stuffing. Implementar rate limiting baseado em endereço IP e identificador de usuário previne tentativas automatizadas de adivinhação de senhas. Estratégia de exponential backoff aumenta progressivamente tempo de bloqueio após tentativas falhas sucessivas. CAPTCHA ou desafios similares adicionam camada de proteção contra automação. Monitoramento de padrões anômalos como tentativas de login de localizações geograficamente dispersas em curto período dispara alertas de segurança.

### Auditoria e Observabilidade

Registrar eventos de autenticação incluindo logins bem-sucedidos, falhas de autenticação, emissão de tokens, renovações e revogações fornece visibilidade crucial para detecção de comprometimento e investigação forense. Logs devem incluir correlation IDs permitindo rastreamento de requisição através de múltiplos serviços, timestamps precisos, endereços IP de origem, user agents, e resultados de validação. Jamais registrar credenciais, tokens completos ou chaves criptográficas em logs. Sistemas SIEM agregam e correlacionam logs de autenticação detectando padrões indicativos de ataques.

## Conclusão

Autenticação em arquiteturas de microsserviços representa desafio multifacetado que exige abordagem arquitetural deliberada distinta de sistemas monolíticos. Centralizar responsabilidade de autenticação em serviço especializado enquanto serviços de domínio assumem exclusivamente validação constitui padrão estabelecido que promove separação de responsabilidades, reutilização de lógica crítica e superfície de ataque reduzida. JSON Web Tokens emergem como mecanismo predominante por natureza autocontida eliminando estado de sessão distribuída, embora introduzam desafios de revogação e renovação endereçados através de Refresh Tokens stateful. Transição de algoritmos simétricos para assimétricos resolve fundamentalmente problema de proliferação de segredos, permitindo distribuição livre de chaves públicas enquanto chave privada permanece exclusivamente no Auth Service. JSON Web Key Set eleva maturidade operacional permitindo rotação dinâmica de chaves sem redeploy de serviços consumidores, implementando cache inteligente para performance e resiliência.

Segurança efetiva transcende implementação correta de criptografia, demandando validação rigorosa de claims, proteção de chaves privadas através de HSMs ou gestão de segredos dedicada, rate limiting contra força bruta, e observabilidade abrangente para detecção de comprometimento. Padrões avançados como OAuth 2.0 e OpenID Connect fornecem frameworks estabelecidos para delegação de autenticação e federação de identidade, enquanto Mutual TLS protege comunicação service-to-service em contextos de alta segurança. Compreensão profunda destes fundamentos permite arquitetar sistemas distribuídos que balanceiam segurança, performance operacional e experiência de usuário, estabelecendo fundação sólida para evolução contínua de arquitetura de microsserviços.

## Referências Bibliográficas

1. **RFC 7519: JSON Web Token (JWT)**. Internet Engineering Task Force, 2015. Disponível em: https://datatracker.ietf.org/doc/html/rfc7519

2. **RFC 7517: JSON Web Key (JWK)**. Internet Engineering Task Force, 2015. Disponível em: https://datatracker.ietf.org/doc/html/rfc7517

3. **RFC 6749: The OAuth 2.0 Authorization Framework**. Internet Engineering Task Force, 2012. Disponível em: https://oauth.net/2/

4. **OpenID Connect Core 1.0**. OpenID Foundation, 2014. Disponível em: https://openid.net/connect/

5. **OWASP API Security Project**. Open Web Application Security Project. Disponível em: https://owasp.org/www-project-api-security/

6. **Keycloak Documentation**. Red Hat. Disponível em: https://www.keycloak.org/documentation

7. **Auth0 Documentation**. Okta. Disponível em: https://auth0.com/docs

8. **Istio Security Documentation**. Istio Authors, 2024. Disponível em: https://istio.io/latest/docs/concepts/security/

9. **Kong Gateway Documentation**. Kong Inc. Disponível em: https://docs.konghq.com/

10. **Microsoft Azure - Authentication in Microservices**. Microsoft Corporation. Disponível em: https://learn.microsoft.com/azure/architecture/microservices/design/gateway

11. **AWS Cognito Documentation**. Amazon Web Services. Disponível em: https://docs.aws.amazon.com/cognito/

12. **Microservices.io - Security Patterns**. Chris Richardson. Disponível em: https://microservices.io/patterns/security/

## Apêndice A: Geração de Par de Chaves RSA

Processo completo de geração de par de chaves RSA utilizando OpenSSL para uso em ambiente de produção:

```bash
# Gerar chave privada RSA 4096 bits com criptografia AES-256
openssl genrsa -aes256 -out private-key-encrypted.pem 4096

# Extrair chave pública
openssl rsa -in private-key-encrypted.pem -pubout -out public-key.pem

# Verificar chave privada
openssl rsa -in private-key-encrypted.pem -check

# Visualizar chave pública em formato legível
openssl rsa -pubin -in public-key.pem -text -noout

# Converter chave privada para formato PKCS8
openssl pkcs8 -topk8 -inform PEM -outform PEM \
  -in private-key-encrypted.pem \
  -out private-key-pkcs8.pem
```

## Apêndice B: Estrutura de JWT Decodificado

Exemplo de JWT completo decodificado demonstrando estrutura de Header, Payload e Signature:

```json
// Header
{
  "alg": "RS256",
  "typ": "JWT",
  "kid": "auth-key-2024-01"
}

// Payload
{
  "userId": 12345,
  "email": "usuario@exemplo.com",
  "role": "admin",
  "permissions": ["read", "write", "delete"],
  "iat": 1704067200,
  "exp": 1704070800,
  "iss": "auth-service",
  "aud": "api-services",
  "sub": "user-authentication",
  "jti": "a3f2b9c7-4d8e-4f2a-9c1b-7e8f9a0b1c2d"
}

// Signature (base64url encoded)
```

## Apêndice C: Implementação de Middleware de Autenticação Genérico

Middleware reutilizável para frameworks Express aplicável a múltiplos serviços:

```typescript
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import jwksClient from 'jwks-rsa';

interface AuthConfig {
  jwksUri: string;
  issuer: string;
  audience: string;
  algorithms: string[];
}

interface AuthenticatedRequest extends Request {
  user?: jwt.JwtPayload;
}

export function createAuthMiddleware(config: AuthConfig) {
  const client = jwksClient({
    jwksUri: config.jwksUri,
    cache: true,
    cacheMaxAge: 600000,
    rateLimit: true,
    jwksRequestsPerMinute: 10
  });

  function getKey(header: jwt.JwtHeader, callback: jwt.SigningKeyCallback) {
    client.getSigningKey(header.kid, (err, key) => {
      if (err) {
        return callback(err);
      }
      const signingKey = key?.getPublicKey();
      callback(null, signingKey);
    });
  }

  return function authenticate(
    req: AuthenticatedRequest,
    res: Response,
    next: NextFunction
  ) {
    const authHeader = req.headers['authorization'];
    const token = authHeader?.split(' ')[1];

    if (!token) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    jwt.verify(token, getKey, {
      algorithms: config.algorithms,
      issuer: config.issuer,
      audience: config.audience,
      clockTolerance: 30
    }, (err, decoded) => {
      if (err) {
        if (err.name === 'TokenExpiredError') {
          return res.status(401).json({ error: 'Token expired' });
        }
        return res.status(403).json({ error: 'Invalid token' });
      }

      req.user = decoded as jwt.JwtPayload;
      next();
    });
  };
}

// Uso em serviço
const authMiddleware = createAuthMiddleware({
  jwksUri: 'http://auth-service:3000/.well-known/jwks.json',
  issuer: 'auth-service',
  audience: 'api-services',
  algorithms: ['RS256', 'RS384', 'RS512']
});

app.use('/api/protected', authMiddleware);
```

## Glossário e Termos Técnicos

**Access Token**: Token de curta duração utilizado para autenticar requisições a recursos protegidos, tipicamente implementado como JWT stateless.

**Algorithm Confusion Attack**: Vulnerabilidade onde atacante modifica header JWT para algoritmo diferente, potencialmente permitindo bypass de validação de assinatura.

**Argon2**: Algoritmo vencedor do Password Hashing Competition projetado para resistir a ataques de força bruta utilizando hardware especializado como GPUs e ASICs.

**Asymmetric Cryptography**: Sistema criptográfico utilizando par de chaves matematicamente relacionadas onde chave pública valida assinaturas criadas por chave privada correspondente.

**Audience (aud)**: Claim JWT identificando destinatários intencionais do token, validado para garantir que token não seja utilizado em serviço não autorizado.

**Certificate Authority**: Entidade confiável que emite certificados digitais X.509 validando identidade de titulares de chaves públicas.

**Clock Skew**: Diferença temporal entre relógios de sistemas distribuídos, endereçada através de tolerância configurável durante validação de claims temporais.

**Credential Stuffing**: Ataque automatizado utilizando pares de credenciais vazadas de outros serviços para tentar acesso não autorizado.

**Hardware Security Module**: Dispositivo físico resistente a adulteração que armazena chaves criptográficas e executa operações criptográficas internamente sem expor material de chave.

**HMAC**: Hash-based Message Authentication Code, função criptográfica combinando hash e chave secreta para autenticar mensagens.

**Issuer (iss)**: Claim JWT identificando entidade que emitiu token, validado para garantir confiança na fonte.

**JSON Web Key**: Formato padronizado RFC 7517 para representar chaves criptográficas em estrutura JSON.

**JSON Web Key Set**: Conjunto de JWKs publicado através de endpoint HTTP permitindo descoberta dinâmica de chaves públicas.

**JSON Web Token**: Padrão RFC 7519 para tokens autocontidos representando claims sobre entidade autenticada, assinados criptograficamente.

**Key ID (kid)**: Identificador único de chave incluído em header JWT permitindo seleção de chave apropriada de conjunto JWKS.

**Mutual TLS**: Autenticação bidirecional onde ambos cliente e servidor apresentam certificados X.509 validando identidade mútua.

**OAuth 2.0**: Framework de autorização RFC 6749 permitindo delegação de acesso a recursos sem compartilhar credenciais.

**OpenID Connect**: Camada de autenticação sobre OAuth 2.0 fornecendo ID Tokens e endpoint UserInfo para identificação de usuários.

**PBKDF2**: Password-Based Key Derivation Function aplicando iterativamente função hash para derivar chave criptográfica de senha, aumentando custo computacional de força bruta.

**Refresh Token**: Token de longa duração armazenado de forma segura utilizado exclusivamente para obter novos Access Tokens sem reapresentar credenciais.

**Replay Attack**: Ataque onde token válido interceptado é reutilizado maliciosamente, mitigado através de expiração curta e validação de claims.

**RS256**: Algoritmo de assinatura assimétrica utilizando RSA com SHA-256, predominante para JWTs em produção.

**Service Mesh**: Camada de infraestrutura dedicada gerenciando comunicação service-to-service incluindo autenticação mTLS, observabilidade e resiliência.

**Symmetric Cryptography**: Sistema criptográfico utilizando chave única compartilhada tanto para criação quanto validação de assinaturas.

**Zero-Trust Network**: Modelo de segurança onde nenhuma comunicação é confiável por padrão, exigindo autenticação e criptografia explícitas para toda interação.