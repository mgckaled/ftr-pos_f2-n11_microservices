<!-- markdownlint-disable -->

# Aula 8: Saga Pattern em Microsserviços

## Resumo Executivo

Saga Pattern constitui padrão arquitetural fundamental para gerenciamento de transações distribuídas em arquiteturas de microsserviços, resolvendo desafio crítico de manutenção de consistência de dados através de múltiplos serviços independentes sem depender de coordenação two-phase commit bloqueante que viola princípio de autonomia e independência operacional. Em sistemas distribuídos caracterizados por Database per Service onde cada microsserviço possui controle exclusivo sobre seu armazenamento de dados, operações de negócio frequentemente requerem modificações coordenadas através de múltiplos contextos limitados, exemplificado por criação de pedido em e-commerce que desencadeia emissão de nota fiscal em serviço Invoice, preparação de envio em serviço Shipping e atualização de inventário em serviço Inventory, onde falha em qualquer etapa necessita reversão de todas modificações anteriores para evitar inconsistências parciais. Saga implementa transação distribuída como sequência de transações locais coordenadas onde cada serviço executa transação ACID individual em seu próprio banco de dados, publicando evento após conclusão bem-sucedida que dispara próxima transação na sequência, enquanto define compensating transaction correspondente para cada operação capaz de desfazer semanticamente modificações realizadas mediante falha em etapa subsequente.

Padrão manifesta-se através de dois modelos fundamentais de coordenação: Orchestration onde serviço central denominado orchestrator gerencia workflow completo através de comandos diretos enviados a cada participante mantendo estado de execução e decidindo próximas etapas baseado em respostas recebidas, apropriado para lógica complexa com decisões condicionais e visibilidade centralizada de progresso; e Choreography onde coordenação emerge através de eventos publicados sem autoridade central, com cada serviço subscrevendo eventos relevantes e reagindo autonomamente publicando novos eventos que propagam execução, favorecendo desacoplamento máximo porém dificultando rastreamento de fluxo completo através de sistema distribuído. Aula demonstra implementação prática de orchestrator customizado utilizando TypeScript para gerenciar deleção de usuário em sistema de encurtamento de URLs, onde remoção de conta em serviço Auth desencadeia saga coordenando deleção de URLs criadas por usuário em serviço Shortener seguida de remoção de dados analíticos em serviço Analytics, com cada etapa implementando soft delete reversível através de timestamps `deleted_at` permitindo compensações restaurarem registros através de operações UPDATE ao invés de recuperação de backups ou reconstrução de estado.

## Introdução e Conceitos

### Desafio de Transações Distribuídas

Arquiteturas monolíticas beneficiam-se de transações ACID gerenciadas por único banco de dados relacional onde `BEGIN TRANSACTION` e `COMMIT` garantem atomicidade através de conjunto completo de operações, permitindo que lógica de negócio como criação de pedido com inserção em múltiplas tabelas relacionadas (Orders, OrderItems, Inventory, Invoices) execute dentro de contexto transacional unificado onde falha em qualquer operação resulta em `ROLLBACK` automático restaurando estado consistente anterior. Migração para microsserviços fragmenta este modelo através de Database per Service onde Orders Service gerencia PostgreSQL exclusivo para pedidos, Invoice Service opera MongoDB para notas fiscais e Inventory Service utiliza Redis para contadores de estoque, eliminando possibilidade de transação distribuída coordenada por único gerenciador.

Two-Phase Commit emerge como solução clássica para transações distribuídas através de coordenador que solicita preparação a todos participantes na fase prepare aguardando confirmação de cada recurso antes de emitir comando global commit ou abort na fase commit, garantindo atomicidade através de bloqueios mantidos durante coordenação. Protocolo enfrenta limitações críticas em ambientes cloud native: bloqueio prolongado de recursos durante preparação e commit degrada throughput substancialmente sob latências variáveis de rede, ponto único de falha no coordenador onde indisponibilidade bloqueia indefinidamente todos participantes aguardando decisão, e acoplamento temporal forte violando princípio de independência operacional onde serviço não pode completar operação sem confirmação síncrona de todos dependentes.

### Definição Formal de Saga

Saga, conceito originalmente proposto por Hector Garcia-Molina e Kenneth Salem em paper acadêmico de 1987 "Sagas", define transação longa como sequência de transações menores `T1, T2, ..., Tn` onde cada `Ti` representa transação local ACID executada por serviço individual, acompanhada de compensating transaction `Ci` capaz de desfazer semanticamente efeitos de `Ti`. Execução bem-sucedida de saga conclui quando todas transações componentes completam com sucesso, formalmente `T1; T2; ...; Tn`, enquanto falha em qualquer etapa `Tk` desencadeia execução de compensações em ordem reversa `Ck-1; Ck-2; ...; C1` restaurando sistema a estado semanticamente equivalente ao anterior à iniciação da saga.

Compensação difere fundamentalmente de rollback tradicional por operar em nível semântico ao invés de mecânico: enquanto `ROLLBACK` em banco de dados desfaz modificações através de undo logs restaurando valores exatos anteriores, compensating transaction executa operação de negócio que anula efeito lógico da transação original. Exemplo demonstra diferença onde transação `T1` debita 100 unidades de conta bancária com saldo inicial 500 resultando em saldo 400, enquanto rollback mecânico restauraria diretamente saldo para 500, compensação `C1` credita 100 unidades ao saldo atual executando operação `UPDATE accounts SET balance = balance + 100` independente de valor presente, tolerando modificações concorrentes ocorridas entre transação original e compensação.

Propriedades fundamentais de sagas estabelecem garantias e limitações: Atomicidade Relaxada onde saga completa integralmente ou compensa completamente mas permite estados intermediários visíveis externamente durante execução, Isolamento Relaxado eliminando serialização tradicional permitindo que outras transações observem e modifiquem dados durante saga em progresso introduzindo anomalias como dirty reads e lost updates, Durabilidade Garantida onde cada transação local `Ti` persiste modificações através de commit em banco de dados próprio antes de prosseguir, e Consistência Eventual onde sistema transita através de estados temporariamente inconsistentes convergindo para consistência após conclusão ou compensação completa.

### Orchestration versus Choreography

Modelos de coordenação de saga diferem fundamentalmente em distribuição de responsabilidades e acoplamento resultante entre serviços participantes.

**Orchestration-based Saga** centraliza lógica de coordenação em componente dedicado denominado orchestrator que atua como controlador de workflow mantendo máquina de estados representando progresso através de saga. Orchestrator envia comandos explícitos a cada serviço participante aguardando confirmação antes de prosseguir, decide próximos passos baseando-se em respostas recebidas incluindo disparar compensações mediante falhas, e persiste estado de execução permitindo recuperação após crashes através de retomada de etapa atual. Implementação típica utiliza filas de comandos onde orchestrator publica comando `DELETE_USER_URLS` para fila dedicada de Shortener Service aguardando evento de confirmação `USER_URLS_DELETED` ou erro `USER_URLS_DELETION_FAILED` antes de enviar próximo comando `DELETE_USER_ANALYTICS` para Analytics Service.

Vantagens incluem visibilidade centralizada onde estado completo de saga reside em única localização facilitando monitoramento e debugging através de queries diretas ao banco de dados de orchestrator, lógica complexa gerenciada naturalmente através de condicionais e loops em código imperativo ao invés de distribuição através de múltiplos event handlers, e facilidade de modificação onde alterações em workflow requerem mudanças exclusivamente em orchestrator sem propagação através de serviços participantes. Desvantagens manifestam-se através de acoplamento onde orchestrator conhece explicitamente todos participantes e detalhes de invocação criando dependência centralizada, ponto único de falha onde indisponibilidade de orchestrator paralisa todas sagas em execução embora menos crítico que two-phase commit pois estado persistido permite recuperação, e potencial gargalo de performance quando único orchestrator gerencia milhares de sagas concorrentes embora mitigável através de sharding horizontal.

**Choreography-based Saga** distribui coordenação através de eventos onde nenhum componente central controla workflow, substituído por serviços reagindo autonomamente a eventos publicados por predecessores na sequência. Execução inicia quando serviço produz evento representando conclusão de transação local como `OrderCreated`, serviços interessados subscrevem evento executando suas próprias transações locais publicando eventos subsequentes como `InvoiceCreated` e `ShipmentPrepared`, e compensações disparam-se através de eventos de falha como `InvoiceCreationFailed` que serviço Order escuta para publicar `OrderCancelled` iniciando cascata de compensações.

Vantagens incluem desacoplamento máximo onde serviços não possuem conhecimento direto de participantes downstream apenas publicando eventos para broker, escalabilidade natural através de paralelização onde múltiplos serviços processam eventos independentemente sem coordenação centralizada, e resiliência elevada onde falha de serviço individual não bloqueia saga inteira pois eventos persistidos em broker aguardam recuperação para reprocessamento. Desvantagens concentram-se em complexidade de rastreamento onde fluxo completo de saga emerge através de múltiplos event handlers distribuídos dificultando debugging e visualização, lógica complexa fragmentada através de serviços onde decisões condicionais requerem coordenação através de eventos adicionais, e risco de dependências cíclicas onde serviços subscrevem mutuamente eventos criando acoplamento implícito difícil de detectar.

## Implementação de Saga Pattern

### Arquitetura de Orchestrator Customizado

Implementação de orchestrator para gerenciamento de sagas requer componentes fundamentais incluindo definições de workflows, rastreamento de estado de execução, e mecanismos de recuperação mediante falhas.

**Definição de Workflow**: Saga representa-se como sequência ordenada de steps onde cada step encapsula action representando transação local a executar e compensation correspondente para reversão. Implementação TypeScript demonstra estrutura:

```typescript
interface SagaStep {
  stepId: string;
  serviceName: string;
  action: {
    topic: string;
    payloadBuilder: (context: SagaContext) => object;
  };
  compensation: {
    topic: string;
    payloadBuilder: (context: SagaContext) => object;
  };
}

interface SagaDefinition {
  sagaId: string;
  name: string;
  steps: SagaStep[];
}

const userDeletionSaga: SagaDefinition = {
  sagaId: 'user-deletion',
  name: 'User Account Deletion Saga',
  steps: [
    {
      stepId: 'delete-user-urls',
      serviceName: 'url-shortener',
      action: {
        topic: 'shortener.delete-user-urls',
        payloadBuilder: (ctx) => ({
          userId: ctx.userId,
          requestId: ctx.sagaInstanceId,
        }),
      },
      compensation: {
        topic: 'shortener.restore-user-urls',
        payloadBuilder: (ctx) => ({
          userId: ctx.userId,
          requestId: ctx.sagaInstanceId,
        }),
      },
    },
    {
      stepId: 'delete-user-analytics',
      serviceName: 'analytics',
      action: {
        topic: 'analytics.delete-user-data',
        payloadBuilder: (ctx) => ({
          userId: ctx.userId,
          requestId: ctx.sagaInstanceId,
        }),
      },
      compensation: {
        topic: 'analytics.restore-user-data',
        payloadBuilder: (ctx) => ({
          userId: ctx.userId,
          requestId: ctx.sagaInstanceId,
        }),
      },
    },
    {
      stepId: 'delete-user-account',
      serviceName: 'auth',
      action: {
        topic: 'auth.delete-user-account',
        payloadBuilder: (ctx) => ({
          userId: ctx.userId,
          requestId: ctx.sagaInstanceId,
        }),
      },
      compensation: {
        topic: 'auth.restore-user-account',
        payloadBuilder: (ctx) => ({
          userId: ctx.userId,
          requestId: ctx.sagaInstanceId,
        }),
      },
    },
  ],
};
```

**Rastreamento de Estado**: Orchestrator persiste estado de cada instância de saga em banco de dados permitindo recuperação após falhas e consultas de progresso. Schema PostgreSQL demonstra estrutura:

```typescript
CREATE TABLE saga_instances (
  saga_instance_id VARCHAR(255) PRIMARY KEY,
  saga_id VARCHAR(255) NOT NULL,
  status VARCHAR(50) NOT NULL, -- 'RUNNING', 'COMPLETED', 'COMPENSATING', 'FAILED'
  current_step_index INTEGER NOT NULL DEFAULT 0,
  context JSONB NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
  completed_at TIMESTAMP,
  INDEX idx_saga_id (saga_id),
  INDEX idx_status (status)
);

CREATE TABLE saga_step_executions (
  execution_id SERIAL PRIMARY KEY,
  saga_instance_id VARCHAR(255) NOT NULL REFERENCES saga_instances(saga_instance_id),
  step_id VARCHAR(255) NOT NULL,
  step_index INTEGER NOT NULL,
  status VARCHAR(50) NOT NULL, -- 'PENDING', 'EXECUTING', 'COMPLETED', 'FAILED', 'COMPENSATING', 'COMPENSATED'
  action_sent_at TIMESTAMP,
  action_completed_at TIMESTAMP,
  compensation_sent_at TIMESTAMP,
  compensation_completed_at TIMESTAMP,
  error_message TEXT,
  INDEX idx_saga_instance (saga_instance_id),
  INDEX idx_step_status (saga_instance_id, status)
);
```

**Implementação de Orchestrator**: Classe central gerencia ciclo de vida de sagas através de métodos para iniciar execução, processar confirmações e disparar compensações:

```typescript
import { Kafka, Producer, Consumer } from 'kafkajs';
import { Pool } from 'pg';

interface SagaContext {
  sagaInstanceId: string;
  userId: string;
  [key: string]: any;
}

class SagaOrchestrator {
  private kafka: Kafka;
  private producer: Producer;
  private consumer: Consumer;
  private db: Pool;
  private sagaDefinitions: Map<string, SagaDefinition>;

  constructor(kafka: Kafka, db: Pool) {
    this.kafka = kafka;
    this.producer = kafka.producer();
    this.consumer = kafka.consumer({ groupId: 'saga-orchestrator' });
    this.db = db;
    this.sagaDefinitions = new Map();
  }

  registerSaga(definition: SagaDefinition): void {
    this.sagaDefinitions.set(definition.sagaId, definition);
  }

  async startSaga(sagaId: string, initialContext: object): Promise<string> {
    const definition = this.sagaDefinitions.get(sagaId);
    if (!definition) {
      throw new Error(`Saga ${sagaId} not found`);
    }

    const sagaInstanceId = this.generateInstanceId();
    const context: SagaContext = {
      sagaInstanceId,
      ...initialContext,
    };

    // Persistir instância de saga
    await this.db.query(
      `INSERT INTO saga_instances (saga_instance_id, saga_id, status, current_step_index, context)
       VALUES ($1, $2, $3, $4, $5)`,
      [sagaInstanceId, sagaId, 'RUNNING', 0, JSON.stringify(context)]
    );

    // Executar primeiro step
    await this.executeStep(sagaInstanceId, definition, 0, context);

    return sagaInstanceId;
  }

  private async executeStep(
    sagaInstanceId: string,
    definition: SagaDefinition,
    stepIndex: number,
    context: SagaContext
  ): Promise<void> {
    const step = definition.steps[stepIndex];

    // Registrar execução de step
    await this.db.query(
      `INSERT INTO saga_step_executions (saga_instance_id, step_id, step_index, status, action_sent_at)
       VALUES ($1, $2, $3, $4, NOW())`,
      [sagaInstanceId, step.stepId, stepIndex, 'EXECUTING']
    );

    // Enviar comando para serviço
    const payload = step.action.payloadBuilder(context);
    await this.producer.send({
      topic: step.action.topic,
      messages: [
        {
          key: sagaInstanceId,
          value: JSON.stringify(payload),
          headers: {
            'saga-instance-id': sagaInstanceId,
            'step-id': step.stepId,
          },
        },
      ],
    });

    console.log(
      `Saga ${sagaInstanceId}: Executed step ${stepIndex} (${step.stepId})`
    );
  }

  async handleStepCompleted(
    sagaInstanceId: string,
    stepId: string
  ): Promise<void> {
    // Atualizar status de step
    await this.db.query(
      `UPDATE saga_step_executions
       SET status = $1, action_completed_at = NOW()
       WHERE saga_instance_id = $2 AND step_id = $3`,
      ['COMPLETED', sagaInstanceId, stepId]
    );

    // Carregar instância de saga
    const instanceResult = await this.db.query(
      `SELECT saga_id, current_step_index, context
       FROM saga_instances
       WHERE saga_instance_id = $1`,
      [sagaInstanceId]
    );

    if (instanceResult.rows.length === 0) {
      throw new Error(`Saga instance ${sagaInstanceId} not found`);
    }

    const { saga_id, current_step_index, context } = instanceResult.rows[0];
    const definition = this.sagaDefinitions.get(saga_id);
    const nextStepIndex = current_step_index + 1;

    if (nextStepIndex < definition.steps.length) {
      // Executar próximo step
      await this.db.query(
        `UPDATE saga_instances
         SET current_step_index = $1, updated_at = NOW()
         WHERE saga_instance_id = $2`,
        [nextStepIndex, sagaInstanceId]
      );

      await this.executeStep(sagaInstanceId, definition, nextStepIndex, context);
    } else {
      // Saga completada
      await this.db.query(
        `UPDATE saga_instances
         SET status = $1, completed_at = NOW()
         WHERE saga_instance_id = $2`,
        ['COMPLETED', sagaInstanceId]
      );

      console.log(`Saga ${sagaInstanceId}: Completed successfully`);
    }
  }

  async handleStepFailed(
    sagaInstanceId: string,
    stepId: string,
    error: string
  ): Promise<void> {
    // Atualizar status de step
    await this.db.query(
      `UPDATE saga_step_executions
       SET status = $1, error_message = $2
       WHERE saga_instance_id = $3 AND step_id = $4`,
      ['FAILED', error, sagaInstanceId, stepId]
    );

    // Marcar saga como compensando
    await this.db.query(
      `UPDATE saga_instances
       SET status = $1, updated_at = NOW()
       WHERE saga_instance_id = $2`,
      ['COMPENSATING', sagaInstanceId]
    );

    // Iniciar compensações
    await this.compensate(sagaInstanceId);
  }

  private async compensate(sagaInstanceId: string): Promise<void> {
    // Carregar instância e steps executados
    const instanceResult = await this.db.query(
      `SELECT saga_id, context FROM saga_instances
       WHERE saga_instance_id = $1`,
      [sagaInstanceId]
    );

    const { saga_id, context } = instanceResult.rows[0];
    const definition = this.sagaDefinitions.get(saga_id);

    const stepsResult = await this.db.query(
      `SELECT step_id, step_index
       FROM saga_step_executions
       WHERE saga_instance_id = $1 AND status = 'COMPLETED'
       ORDER BY step_index DESC`,
      [sagaInstanceId]
    );

    // Compensar steps em ordem reversa
    for (const row of stepsResult.rows) {
      const step = definition.steps[row.step_index];

      await this.db.query(
        `UPDATE saga_step_executions
         SET status = $1, compensation_sent_at = NOW()
         WHERE saga_instance_id = $2 AND step_id = $3`,
        ['COMPENSATING', sagaInstanceId, step.stepId]
      );

      const payload = step.compensation.payloadBuilder(context);
      await this.producer.send({
        topic: step.compensation.topic,
        messages: [
          {
            key: sagaInstanceId,
            value: JSON.stringify(payload),
            headers: {
              'saga-instance-id': sagaInstanceId,
              'step-id': step.stepId,
              'compensation': 'true',
            },
          },
        ],
      });

      console.log(
        `Saga ${sagaInstanceId}: Compensating step ${row.step_index} (${step.stepId})`
      );
    }
  }

  async handleCompensationCompleted(
    sagaInstanceId: string,
    stepId: string
  ): Promise<void> {
    await this.db.query(
      `UPDATE saga_step_executions
       SET status = $1, compensation_completed_at = NOW()
       WHERE saga_instance_id = $2 AND step_id = $3`,
      ['COMPENSATED', sagaInstanceId, stepId]
    );

    // Verificar se todas compensações completaram
    const pendingResult = await this.db.query(
      `SELECT COUNT(*) as count
       FROM saga_step_executions
       WHERE saga_instance_id = $1 AND status = 'COMPENSATING'`,
      [sagaInstanceId]
    );

    if (parseInt(pendingResult.rows[0].count) === 0) {
      await this.db.query(
        `UPDATE saga_instances
         SET status = $1, completed_at = NOW()
         WHERE saga_instance_id = $2`,
        ['FAILED', sagaInstanceId]
      );

      console.log(`Saga ${sagaInstanceId}: Compensated and failed`);
    }
  }

  private generateInstanceId(): string {
    return `saga_${Date.now()}_${Math.random().toString(36).substring(7)}`;
  }
}
```

### Implementação de Serviços Participantes

Serviços participantes implementam handlers para processar ações e compensações enviadas por orchestrator, executando transações locais e confirmando conclusão através de eventos.

**URL Shortener Service**: Implementa soft delete para URLs permitindo reversão através de restauração de timestamps:

```typescript
import { Kafka, EachMessagePayload } from 'kafkajs';
import { Pool } from 'pg';

const kafka = new Kafka({
  clientId: 'url-shortener',
  brokers: ['localhost:9092'],
});

const consumer = kafka.consumer({ groupId: 'url-shortener-saga' });
const producer = kafka.producer();
const db = new Pool({ connectionString: process.env.DATABASE_URL });

async function handleDeleteUserUrls(payload: {
  userId: string;
  requestId: string;
}): Promise<void> {
  const { userId, requestId } = payload;

  try {
    const result = await db.query(
      `UPDATE urls
       SET deleted_at = NOW()
       WHERE user_id = $1 AND deleted_at IS NULL
       RETURNING id`,
      [userId]
    );

    console.log(
      `Deleted ${result.rowCount} URLs for user ${userId} (request ${requestId})`
    );

    // Confirmar conclusão
    await producer.send({
      topic: 'orchestrator.step-completed',
      messages: [
        {
          key: requestId,
          value: JSON.stringify({
            sagaInstanceId: requestId,
            stepId: 'delete-user-urls',
            deletedCount: result.rowCount,
          }),
        },
      ],
    });
  } catch (error) {
    console.error(`Error deleting URLs for user ${userId}:`, error);

    // Notificar falha
    await producer.send({
      topic: 'orchestrator.step-failed',
      messages: [
        {
          key: requestId,
          value: JSON.stringify({
            sagaInstanceId: requestId,
            stepId: 'delete-user-urls',
            error: error.message,
          }),
        },
      ],
    });
  }
}

async function handleRestoreUserUrls(payload: {
  userId: string;
  requestId: string;
}): Promise<void> {
  const { userId, requestId } = payload;

  const result = await db.query(
    `UPDATE urls
     SET deleted_at = NULL
     WHERE user_id = $1 AND deleted_at IS NOT NULL
     RETURNING id`,
    [userId]
  );

  console.log(
    `Restored ${result.rowCount} URLs for user ${userId} (request ${requestId})`
  );

  // Confirmar compensação
  await producer.send({
    topic: 'orchestrator.compensation-completed',
    messages: [
      {
        key: requestId,
        value: JSON.stringify({
          sagaInstanceId: requestId,
          stepId: 'delete-user-urls',
          restoredCount: result.rowCount,
        }),
      },
    ],
  });
}

async function run(): Promise<void> {
  await consumer.connect();
  await producer.connect();

  await consumer.subscribe({
    topics: ['shortener.delete-user-urls', 'shortener.restore-user-urls'],
  });

  await consumer.run({
    eachMessage: async ({ topic, message }: EachMessagePayload) => {
      const payload = JSON.parse(message.value.toString());

      if (topic === 'shortener.delete-user-urls') {
        await handleDeleteUserUrls(payload);
      } else if (topic === 'shortener.restore-user-urls') {
        await handleRestoreUserUrls(payload);
      }
    },
  });
}

run().catch(console.error);
```

**Analytics Service**: Similarmente implementa soft delete e restauração para dados analíticos:

```typescript
async function handleDeleteUserAnalytics(payload: {
  userId: string;
  requestId: string;
}): Promise<void> {
  const { userId, requestId } = payload;

  try {
    await db.transaction(async (tx) => {
      const urlsResult = await tx.query(
        `UPDATE analytics_urls
         SET deleted_at = NOW()
         WHERE user_id = $1 AND deleted_at IS NULL
         RETURNING id`,
        [userId]
      );

      const eventsResult = await tx.query(
        `UPDATE analytics_events
         SET deleted_at = NOW()
         WHERE user_id = $1 AND deleted_at IS NULL
         RETURNING id`,
        [userId]
      );

      console.log(
        `Deleted ${urlsResult.rowCount} URLs and ${eventsResult.rowCount} events for user ${userId}`
      );
    });

    await producer.send({
      topic: 'orchestrator.step-completed',
      messages: [
        {
          key: requestId,
          value: JSON.stringify({
            sagaInstanceId: requestId,
            stepId: 'delete-user-analytics',
          }),
        },
      ],
    });
  } catch (error) {
    await producer.send({
      topic: 'orchestrator.step-failed',
      messages: [
        {
          key: requestId,
          value: JSON.stringify({
            sagaInstanceId: requestId,
            stepId: 'delete-user-analytics',
            error: error.message,
          }),
        },
      ],
    });
  }
}

async function handleRestoreUserAnalytics(payload: {
  userId: string;
  requestId: string;
}): Promise<void> {
  const { userId, requestId } = payload;

  await db.transaction(async (tx) => {
    await tx.query(
      `UPDATE analytics_urls SET deleted_at = NULL
       WHERE user_id = $1 AND deleted_at IS NOT NULL`,
      [userId]
    );

    await tx.query(
      `UPDATE analytics_events SET deleted_at = NULL
       WHERE user_id = $1 AND deleted_at IS NOT NULL`,
      [userId]
    );
  });

  await producer.send({
    topic: 'orchestrator.compensation-completed',
    messages: [
      {
        key: requestId,
        value: JSON.stringify({
          sagaInstanceId: requestId,
          stepId: 'delete-user-analytics',
        }),
      },
    ],
  });
}
```

### Implementação Choreography-based

Alternativa a orchestrator centralizado distribui coordenação através de eventos onde cada serviço reage autonomamente:

```typescript
// Order Service
class OrderService {
  async createOrder(orderData: OrderData): Promise<void> {
    const order = await this.db.query(
      `INSERT INTO orders (id, customer_id, total, status)
       VALUES ($1, $2, $3, $4) RETURNING *`,
      [randomUUID(), orderData.customerId, orderData.total, 'PENDING']
    );

    // Publicar evento
    await this.producer.send({
      topic: 'orders.created',
      messages: [
        {
          key: order.id,
          value: JSON.stringify({
            orderId: order.id,
            customerId: order.customer_id,
            items: orderData.items,
            total: order.total,
          }),
        },
      ],
    });
  }

  async handleInvoiceCreationFailed(event: {
    orderId: string;
    reason: string;
  }): Promise<void> {
    // Compensar: cancelar pedido
    await this.db.query(
      `UPDATE orders SET status = $1, cancelled_reason = $2
       WHERE id = $3`,
      ['CANCELLED', event.reason, event.orderId]
    );

    // Publicar evento de cancelamento
    await this.producer.send({
      topic: 'orders.cancelled',
      messages: [
        {
          key: event.orderId,
          value: JSON.stringify({
            orderId: event.orderId,
            reason: event.reason,
          }),
        },
      ],
    });
  }
}

// Invoice Service
class InvoiceService {
  async handleOrderCreated(event: OrderCreatedEvent): Promise<void> {
    try {
      const invoice = await this.createInvoice(event);

      await this.producer.send({
        topic: 'invoices.created',
        messages: [
          {
            key: event.orderId,
            value: JSON.stringify({
              orderId: event.orderId,
              invoiceId: invoice.id,
              amount: invoice.amount,
            }),
          },
        ],
      });
    } catch (error) {
      await this.producer.send({
        topic: 'invoices.creation-failed',
        messages: [
          {
            key: event.orderId,
            value: JSON.stringify({
              orderId: event.orderId,
              reason: error.message,
            }),
          },
        ],
      });
    }
  }

  async handleOrderCancelled(event: OrderCancelledEvent): Promise<void> {
    // Compensar: cancelar nota fiscal se existir
    await this.db.query(
      `UPDATE invoices SET status = $1
       WHERE order_id = $2`,
      ['CANCELLED', event.orderId]
    );
  }
}
```

## Desafios e Padrões Avançados

### Anomalias de Isolamento

Ausência de isolamento ACID tradicional em sagas introduz anomalias clássicas de concorrência exigindo contramedidas específicas:

**Dirty Reads**: Transação externa lê dados modificados por saga ainda em execução que posteriormente compensa, resultando em leitura de valor temporário invalidado. Exemplo onde Saga1 debita conta A e credita conta B, enquanto consulta externa lê saldo de B antes de compensação reverter operação, observando saldo inflado temporariamente.

Contramedida através de **Semantic Lock**: Adicionar campo de status em registros modificados por saga marcando-os como em processamento, prevenindo leitura ou modificação até conclusão ou compensação. Implementação adiciona coluna `saga_lock_id`:

```typescript
// Saga adquire lock semântico
await db.query(
  `UPDATE accounts
   SET balance = balance - $1, saga_lock_id = $2
   WHERE id = $3 AND saga_lock_id IS NULL`,
  [amount, sagaInstanceId, accountId]
);

// Query externa respeita lock
await db.query(
  `SELECT * FROM accounts
   WHERE id = $1 AND saga_lock_id IS NULL`,
  [accountId]
);

// Saga libera lock após conclusão
await db.query(
  `UPDATE accounts SET saga_lock_id = NULL
   WHERE saga_lock_id = $1`,
  [sagaInstanceId]
);
```

**Lost Updates**: Duas sagas modificam concorrentemente mesmo registro onde segunda sobrescreve modificações da primeira. Exemplo onde Saga1 e Saga2 incrementam contador concorrentemente perdendo uma das atualizações.

Contramedida através de **Commutative Updates**: Estruturar operações como comutativas onde ordem de aplicação não afeta resultado final, exemplificado por `UPDATE counter SET value = value + 1` ao invés de `UPDATE counter SET value = X` com valor calculado anteriormente.

### Timeouts e Retentativas

Sagas enfrentam desafio de distinguir falhas permanentes que exigem compensação de falhas temporárias recuperáveis através de retentativas. Orchestrator implementa políticas de timeout e retry:

```typescript
interface RetryPolicy {
  maxAttempts: number;
  backoffMs: number;
  maxBackoffMs: number;
  timeoutMs: number;
}

class SagaOrchestrator {
  private async executeStepWithRetry(
    sagaInstanceId: string,
    definition: SagaDefinition,
    stepIndex: number,
    context: SagaContext,
    retryPolicy: RetryPolicy
  ): Promise<void> {
    let attempt = 0;
    let backoff = retryPolicy.backoffMs;

    while (attempt < retryPolicy.maxAttempts) {
      try {
        await this.executeStepWithTimeout(
          sagaInstanceId,
          definition,
          stepIndex,
          context,
          retryPolicy.timeoutMs
        );
        return; // Sucesso
      } catch (error) {
        attempt++;

        if (attempt >= retryPolicy.maxAttempts) {
          // Esgotadas tentativas, iniciar compensação
          throw error;
        }

        console.log(
          `Saga ${sagaInstanceId}: Retry attempt ${attempt} after ${backoff}ms`
        );

        await this.sleep(backoff);
        backoff = Math.min(backoff * 2, retryPolicy.maxBackoffMs);
      }
    }
  }

  private async executeStepWithTimeout(
    sagaInstanceId: string,
    definition: SagaDefinition,
    stepIndex: number,
    context: SagaContext,
    timeoutMs: number
  ): Promise<void> {
    return Promise.race([
      this.executeStep(sagaInstanceId, definition, stepIndex, context),
      this.timeoutPromise(timeoutMs),
    ]);
  }

  private timeoutPromise(ms: number): Promise<never> {
    return new Promise((_, reject) =>
      setTimeout(() => reject(new Error('Step timeout')), ms)
    );
  }

  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}
```

### Compensações Idempotentes

Compensating transactions devem ser idempotentes tolerando execuções múltiplas sem efeitos colaterais adicionais, crítico quando retentativas de compensação ocorrem após falhas de rede. Implementação utiliza padrões:

```typescript
async function compensateOrderCreation(orderId: string): Promise<void> {
  // Idempotente através de verificação de estado
  const result = await db.query(
    `UPDATE orders
     SET status = 'CANCELLED', cancelled_at = NOW()
     WHERE id = $1 AND status != 'CANCELLED'
     RETURNING id`,
    [orderId]
  );

  if (result.rowCount === 0) {
    console.log(`Order ${orderId} already cancelled, skipping`);
  }
}

async function compensatePayment(
  paymentId: string,
  amount: number
): Promise<void> {
  // Idempotente através de rastreamento de compensações
  const compensationId = generateCompensationId(paymentId);

  const existing = await db.query(
    `SELECT id FROM payment_compensations
     WHERE compensation_id = $1`,
    [compensationId]
  );

  if (existing.rows.length > 0) {
    console.log(`Payment ${paymentId} already compensated`);
    return;
  }

  await db.transaction(async (tx) => {
    await tx.query(
      `INSERT INTO payment_compensations (compensation_id, payment_id, amount)
       VALUES ($1, $2, $3)`,
      [compensationId, paymentId, amount]
    );

    await tx.query(
      `UPDATE accounts SET balance = balance + $1
       WHERE id = (SELECT account_id FROM payments WHERE id = $2)`,
      [amount, paymentId]
    );
  });
}
```

## Conclusões

Saga Pattern estabelece-se como solução fundamental para gerenciamento de transações distribuídas em arquiteturas de microsserviços, oferecendo alternativa pragmática a two-phase commit através de relaxamento de garantias ACID tradicionais em favor de consistência eventual e compensações semânticas. Implementação efetiva requer decisões arquiteturais ponderadas entre orchestration fornecendo visibilidade centralizada e controle explícito de workflow porém introduzindo acoplamento a componente coordenador, versus choreography maximizando desacoplamento e escalabilidade horizontal através de coordenação emergente baseada em eventos porém dificultando rastreamento e debugging de fluxos complexos. Escolha apropriada depende de características específicas de domínio onde workflows lineares com lógica condicional limitada favorecem orchestration permitindo expressão natural através de código imperativo, enquanto processos altamente distribuídos com múltiplos caminhos paralelos beneficiam-se de choreography explorando paralelização inerente e resiliência a falhas parciais.

Desafios substanciais emergem através de anomalias de isolamento incluindo dirty reads e lost updates exigindo contramedidas como semantic locks marcando registros em processamento e commutative updates estruturando operações independentes de ordem, complexidade de compensações que devem ser idempotentes e semanticamente corretas desfazendo efeitos lógicos ao invés de reversão mecânica de bytes, e gestão de timeouts e retentativas distinguindo falhas temporárias recuperáveis de permanentes que desencadeiam cascatas de compensações através de workflow. Observabilidade torna-se crítica em sistemas de produção demandando correlation IDs propagados através de todos eventos e comandos permitindo rastreamento end-to-end, logs estruturados capturando transições de estado de saga e execuções de steps facilitando debugging de falhas, e dashboards visualizando sagas em execução com métricas de duração, taxa de sucesso e frequência de compensações identificando gargalos e componentes problemáticos.

Evolução futura concentra-se em frameworks especializados como Axon Framework para JVM oferecendo abstrações de alto nível para sagas baseadas em event sourcing com recuperação automática de estado, Temporal para Go e Java fornecendo workflow engine durável que garante execução completa mesmo mediante crashes através de persistência de histórico, e Camunda implementando BPMN permitindo modelagem visual de workflows complexos com integração nativa a serviços através de conectores. Adoção crescente de service mesh como Istio e Linkerd introduz oportunidades de implementação de sagas em nível de infraestrutura onde sidecars Envoy interceptam comunicação entre serviços aplicando políticas de retry, timeout e circuit breaking transparentemente, potencialmente abstraindo complexidade de coordenação de lógica de aplicação embora limitado a padrões request-response síncronos sem suporte natural a compensações assíncronas baseadas em eventos.

## Referências Bibliográficas

1. **Garcia-Molina, Hector; Salem, Kenneth. "Sagas"**. Proceedings of the 1987 ACM SIGMOD International Conference on Management of Data. Paper acadêmico original que introduziu conceito de Saga Pattern para transações longas.

2. **Microservices.io - Saga Pattern**. Chris Richardson. Disponível em: https://microservices.io/patterns/data/saga.html. Documentação completa do padrão incluindo variações de orchestration e choreography.

3. **Microsoft Azure Architecture - Saga Pattern**. Microsoft. Disponível em: https://learn.microsoft.com/azure/architecture/reference-architectures/saga/saga. Design patterns e implementação de sagas em ambientes cloud.

4. **AWS Prescriptive Guidance - Saga Pattern**. Amazon Web Services. Disponível em: https://docs.aws.amazon.com/prescriptive-guidance/latest/modernization-data-persistence/saga-pattern.html. Guidance para modernização de persistência utilizando sagas.

5. **Axon Framework Documentation - Sagas**. AxonIQ. Disponível em: https://docs.axoniq.io/reference-guide/axon-framework/sagas. Implementação robusta de sagas com event sourcing e CQRS.

6. **Seata - Distributed Transaction Solution**. Apache Software Foundation. Disponível em: https://seata.io/. Framework open-source para transações distribuídas em arquiteturas de microsserviços.

7. **Temporal Documentation**. Temporal Technologies. Disponível em: https://docs.temporal.io/. Workflow engine durável para orquestração de sagas de longa duração.

8. **Camunda BPMN Reference**. Camunda. Disponível em: https://camunda.com/bpmn/reference/. Modelagem visual de workflows complexos utilizando BPMN para orquestração.

9. **Netflix Conductor**. Netflix. Disponível em: https://conductor.netflix.com/documentation/. Workflow orchestration engine open-source para microsserviços.

10. **Enterprise Integration Patterns - Process Manager**. Gregor Hohpe. Disponível em: https://www.enterpriseintegrationpatterns.com/. Padrões de integração relacionados a coordenação de processos distribuídos.

## Apêndice A: Comparação Orchestration versus Choreography

| Aspecto | Orchestration | Choreography |
|---------|---------------|--------------|
| **Coordenação** | Centralizada em orchestrator | Distribuída via eventos |
| **Acoplamento** | Serviços conhecem orchestrator | Serviços desacoplados via broker |
| **Visibilidade** | Estado centralizado facilita monitoramento | Estado distribuído dificulta rastreamento |
| **Lógica Complexa** | Código imperativo em orchestrator | Fragmentada através de event handlers |
| **Escalabilidade** | Orchestrator pode tornar-se gargalo | Escalabilidade horizontal natural |
| **Resiliência** | Ponto único de falha (mitigado por persistência) | Falhas isoladas não bloqueiam saga |
| **Modificação** | Mudanças concentradas em orchestrator | Mudanças propagam-se através de serviços |
| **Debugging** | Facilita debugging através de logs centralizados | Requer correlation IDs e agregação de logs |

## Apêndice B: Glossário e Termos Técnicos

**Atomicidade Relaxada**: Propriedade de saga onde transação completa integralmente ou compensa completamente, mas permite estados intermediários visíveis durante execução diferente de ACID tradicional.

**Choreography**: Modelo de coordenação de saga baseado em eventos onde coordenação emerge através de serviços reagindo autonomamente sem autoridade central.

**Commutative Updates**: Operações estruturadas de forma que ordem de execução não afeta resultado final, contramedida para lost updates em sagas concorrentes.

**Compensating Transaction**: Operação que desfaz semanticamente efeitos de transação local original, diferindo de rollback mecânico através de execução de lógica de negócio inversa.

**Consistência Eventual**: Modelo onde sistema transita através de estados temporariamente inconsistentes convergindo para consistência após conclusão ou compensação completa de saga.

**Dirty Reads**: Anomalia onde transação externa lê dados modificados por saga ainda em execução que posteriormente compensa, observando valores temporários invalidados.

**Isolamento Relaxado**: Ausência de serialização tradicional em sagas permitindo que outras transações observem e modifiquem dados durante saga em progresso.

**Lost Updates**: Anomalia onde modificações concorrentes de múltiplas sagas em mesmo registro resultam em sobrescrita de atualizações.

**Orchestration**: Modelo de coordenação de saga onde componente central gerencia workflow através de comandos explícitos a participantes.

**Orchestrator**: Componente centralizado responsável por gerenciar ciclo de vida de saga incluindo envio de comandos, rastreamento de estado e disparo de compensações.

**Saga**: Transação distribuída implementada como sequência de transações locais coordenadas onde cada etapa possui compensating transaction correspondente para reversão.

**Saga Instance**: Execução específica de saga definition com estado próprio e contexto contendo dados propagados através de steps.

**Semantic Lock**: Contramedida para dirty reads adicionando marcador em registros indicando processamento por saga, prevenindo leitura ou modificação até conclusão.

**Soft Delete**: Padrão onde registros marcam-se como deletados através de timestamp ao invés de remoção física, permitindo reversão através de operações UPDATE.

**Step**: Etapa individual em saga representando transação local com action a executar e compensation para reversão.

**Two-Phase Commit**: Protocolo de transação distribuída coordenando commit atômico através de múltiplos recursos via fases prepare e commit, geralmente evitado em microsserviços devido a bloqueio prolongado.

**Workflow**: Sequência ordenada de steps definindo saga incluindo lógica condicional, paralelização e dependências entre etapas.
