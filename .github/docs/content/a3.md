<!-- markdownlint-disable -->

# Persistência em Microsserviços: Desafios, Padrões e Estratégias

## Resumo Executivo

A persistência de dados em arquiteturas de microsserviços representa desafio fundamental que distingue substancialmente esta abordagem de sistemas monolíticos tradicionais. O princípio fundamental de que cada microsserviço deve possuir seu próprio armazenamento de dados, conhecido como "Database per Service", introduz complexidades significativas relacionadas a duplicação controlada de dados, consistência eventual, integridade referencial e coordenação de transações distribuídas. Este documento explora as motivações técnicas e arquiteturais para isolamento de bancos de dados, examina os desafios de duplicação e sincronização de dados entre serviços, apresenta padrões como Soft References para manutenção de integridade referencial sem acoplamento direto via Foreign Keys, e discute estratégias avançadas incluindo Event Sourcing, CQRS e Saga Pattern para gerenciamento de transações distribuídas. Compreender estes conceitos e dominar sua implementação prática é essencial para arquitetos e desenvolvedores construindo sistemas distribuídos robustos e escaláveis.

## Introdução e Conceitos Fundamentais

### O Imperativo do Isolamento de Dados

Em arquiteturas monolíticas, compartilhamento de banco de dados entre módulos representa prática comum e natural. Componentes distintos acessam mesmas tabelas, compartilham esquemas comuns e estabelecem relacionamentos diretos via Foreign Keys. Este compartilhamento simplifica consistência transacional através de ACID garantido por banco de dados relacional.

Microsserviços invertem fundamentalmente este paradigma. O princípio "Database per Service" estabelece que cada microsserviço deve ter controle exclusivo sobre seu armazenamento de dados. Este isolamento não é meramente recomendação arquitetural, mas requisito essencial para alcançar independência operacional característica de microsserviços.

**Motivações para Isolamento de Dados**:

**Independência de Deploy**: Alterações no esquema de banco de dados de um serviço não devem requerer coordenação ou impactar outros serviços. Cada serviço evolui seu modelo de dados independentemente.

**Autonomia Tecnológica**: Serviços podem escolher tecnologia de persistência mais apropriada para suas necessidades específicas. Um serviço pode utilizar PostgreSQL para dados transacionais, outro MongoDB para documentos flexíveis, outro Redis para caching de alta performance.

**Isolamento de Falhas**: Problemas de performance ou indisponibilidade de banco de dados de um serviço não propagam-se diretamente para outros serviços. Contenção de falhas em nível de persistência.

**Escalabilidade Independente**: Serviços com demandas distintas de persistência podem escalar armazenamento independentemente. Serviço com alta carga de escrita pode ter infraestrutura otimizada diferente de serviço predominantemente de leitura.

**Encapsulamento de Domínio**: Dados são parte da implementação interna do serviço, não interface pública. Outros serviços comunicam-se apenas via APIs bem definidas, nunca acessando banco de dados diretamente.

### Consequências do Isolamento

Isolamento de dados resolve desafios de acoplamento mas introduz complexidades substanciais que não existem em monolitos:

**Duplicação de Dados**: Informações necessárias por múltiplos serviços devem ser replicadas através de fronteiras de serviço. Cliente que faz pedido tem dados replicados em serviço de Orders, Invoices, Shipping.

**Consistência Eventual**: Atualizações propagam-se através de serviços via comunicação assíncrona. Sistema transita através de estados temporariamente inconsistentes antes de convergir.

**Ausência de Transações Distribuídas Simples**: Operações atravessando múltiplos serviços não podem utilizar transações ACID tradicionais. Padrões compensatórios como Saga Pattern tornam-se necessários.

**Complexidade de Consultas**: Queries que em monolito seriam simples JOINs requerem composição de dados atravessando múltiplos serviços via APIs ou agregação eventual em serviços especializados.

## Database per Service Pattern

### Implementação e Variações

O padrão Database per Service pode manifestar-se em diferentes formas conforme requisitos específicos:

**Banco de Dados Físico Separado**: Cada serviço possui instância completamente isolada de banco de dados. Máximo isolamento mas maior overhead operacional.

**Esquemas Separados em Instância Compartilhada**: Serviços compartilham instância de banco de dados mas utilizam esquemas (schemas) distintos. Economia operacional mantendo isolamento lógico.

**Tecnologias Heterogêneas**: Serviços diferentes utilizam tecnologias de banco de dados completamente distintas baseado em requisitos específicos.

Exemplo de estrutura com esquemas separados em PostgreSQL:

```typescript
// Serviço de Orders - Schema 'orders'
CREATE SCHEMA orders;

CREATE TABLE orders.customers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) NOT NULL UNIQUE,
  document VARCHAR(14) NOT NULL,
  address JSONB NOT NULL,
  payment_info JSONB NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE orders.orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  customer_id UUID NOT NULL,
  total_amount DECIMAL(12, 2) NOT NULL,
  status VARCHAR(50) NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (customer_id) REFERENCES orders.customers(id)
);

// Serviço de Invoices - Schema 'invoices'
CREATE SCHEMA invoices;

CREATE TABLE invoices.customers (
  id UUID PRIMARY KEY,
  orders_customer_id UUID NOT NULL, -- Soft reference
  email VARCHAR(255) NOT NULL,
  document VARCHAR(14) NOT NULL,
  address JSONB NOT NULL,
  synced_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE invoices.invoices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  customer_id UUID NOT NULL,
  order_id UUID NOT NULL,
  invoice_number VARCHAR(100) NOT NULL UNIQUE,
  total_amount DECIMAL(12, 2) NOT NULL,
  issued_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (customer_id) REFERENCES invoices.customers(id)
);
```

Observe que `invoices.customers` não possui Foreign Key para `orders.customers` pois residem em domínios isolados. A coluna `orders_customer_id` funciona como Soft Reference.

### Escolha de Tecnologia por Serviço

Autonomia tecnológica permite otimização específica por caso de uso:

```typescript
// Serviço de URL Shortener - MongoDB
import { MongoClient, Db, Collection } from 'mongodb';

interface UrlDocument {
  _id?: string;
  originalUrl: string;
  shortCode: string;
  clickCount: number;
  createdAt: Date;
  userId?: string;
}

class UrlShortenerRepository {
  private collection: Collection<UrlDocument>;

  constructor(db: Db) {
    this.collection = db.collection<UrlDocument>('urls');
  }

  async create(url: Omit<UrlDocument, '_id' | 'clickCount' | 'createdAt'>): Promise<UrlDocument> {
    const doc: UrlDocument = {
      ...url,
      clickCount: 0,
      createdAt: new Date()
    };

    const result = await this.collection.insertOne(doc);
    return { ...doc, _id: result.insertedId.toString() };
  }

  async findByShortCode(shortCode: string): Promise<UrlDocument | null> {
    return await this.collection.findOne({ shortCode });
  }
}
```

```typescript
// Serviço de Analytics - ClickHouse (Time Series DB)
import { createClient } from '@clickhouse/client';

interface UrlClickEvent {
  url_id: string;
  short_code: string;
  clicked_at: Date;
  ip_address?: string;
  user_agent?: string;
  country?: string;
  referer?: string;
}

class AnalyticsRepository {
  private client;

  constructor() {
    this.client = createClient({
      host: 'http://clickhouse:8123',
      database: 'analytics'
    });
  }

  async recordClick(event: UrlClickEvent): Promise<void> {
    await this.client.insert({
      table: 'url_clicks',
      values: [{
        url_id: event.url_id,
        short_code: event.short_code,
        clicked_at: event.clicked_at.toISOString(),
        ip_address: event.ip_address || null,
        user_agent: event.user_agent || null,
        country: event.country || null,
        referer: event.referer || null
      }],
      format: 'JSONEachRow'
    });
  }

  async getClicksByUrl(urlId: string, startDate: Date, endDate: Date): Promise<number> {
    const result = await this.client.query({
      query: `
        SELECT count(*) as total
        FROM url_clicks
        WHERE url_id = {urlId:String}
          AND clicked_at BETWEEN {startDate:DateTime} AND {endDate:DateTime}
      `,
      query_params: {
        urlId,
        startDate: startDate.toISOString(),
        endDate: endDate.toISOString()
      }
    });

    const rows = await result.json();
    return Number(rows.data[0].total);
  }
}
```

Esta heterogeneidade permite que URL Shortener utilize MongoDB para flexibilidade documental enquanto Analytics aproveita ClickHouse otimizado para agregações analíticas sobre grandes volumes temporais.

## Duplicação Controlada de Dados

### Motivação e Estratégia

Duplicação de dados em microsserviços não representa falha arquitetural mas estratégia deliberada para alcançar autonomia. A questão não é se haverá duplicação, mas sim quais dados duplicar e como mantê-los sincronizados.

**Princípios para Duplicação**:

**Duplicar Apenas Necessário**: Copiar somente dados essenciais para operação do serviço, não todos os atributos da entidade original.

**Identificar Autoridade de Dados**: Para cada entidade, definir claramente qual serviço é autoridade (source of truth). Outros serviços mantêm cópias somente leitura.

**Sincronização Via Eventos**: Propagação de mudanças através de eventos assíncronos, não consultas síncronas contínuas.

**Tolerar Inconsistência Temporária**: Aceitar que réplicas podem estar temporariamente desatualizadas. Sistema converge eventualmente.

### Exemplo Prático: E-commerce

Considerando sistema de e-commerce com serviços Orders, Invoices e Shipping:

```typescript
// Serviço Orders - Entidade Customer (Autoridade)
interface OrdersCustomer {
  id: string;
  email: string;
  document: string;
  fullName: string;
  phone: string;
  shippingAddress: {
    street: string;
    number: string;
    city: string;
    state: string;
    zipCode: string;
    country: string;
  };
  billingAddress: {
    street: string;
    number: string;
    city: string;
    state: string;
    zipCode: string;
    country: string;
  };
  paymentMethods: Array<{
    id: string;
    type: 'credit_card' | 'debit_card' | 'pix';
    lastFourDigits?: string;
    expiryDate?: string;
  }>;
  createdAt: Date;
  updatedAt: Date;
}
```

```typescript
// Serviço Invoices - Cópia Parcial de Customer
interface InvoicesCustomer {
  id: string;
  ordersCustomerId: string; // Soft reference
  email: string;
  document: string;
  fullName: string;
  billingAddress: {
    street: string;
    number: string;
    city: string;
    state: string;
    zipCode: string;
    country: string;
  };
  syncedAt: Date;
}
```

Invoices necessita apenas dados para emissão de nota fiscal. Não precisa telefone, endereço de entrega ou métodos de pagamento. Esta seleção intencional reduz acoplamento e tráfego de sincronização.

```typescript
// Serviço Shipping - Cópia Parcial de Customer
interface ShippingCustomer {
  id: string;
  ordersCustomerId: string; // Soft reference
  email: string;
  fullName: string;
  phone: string;
  shippingAddress: {
    street: string;
    number: string;
    city: string;
    state: string;
    zipCode: string;
    country: string;
  };
  syncedAt: Date;
}
```

Shipping necessita endereço de entrega e telefone para logística, mas não dados de pagamento ou endereço de cobrança.

### Sincronização Via Eventos

Quando customer é criado ou atualizado em Orders, eventos propagam mudanças relevantes:

```typescript
// Serviço Orders - Publicação de eventos
import { z } from 'zod';

export const customerCreatedEventSchema = z.object({
  customerId: z.string().uuid(),
  email: z.string().email(),
  document: z.string(),
  fullName: z.string(),
  phone: z.string().optional(),
  shippingAddress: z.object({
    street: z.string(),
    number: z.string(),
    city: z.string(),
    state: z.string(),
    zipCode: z.string(),
    country: z.string()
  }),
  billingAddress: z.object({
    street: z.string(),
    number: z.string(),
    city: z.string(),
    state: z.string(),
    zipCode: z.string(),
    country: z.string()
  }),
  createdAt: z.string().datetime()
});

export type CustomerCreatedEvent = z.infer<typeof customerCreatedEventSchema>;

async function publishCustomerCreated(customer: OrdersCustomer): Promise<void> {
  const event: CustomerCreatedEvent = {
    customerId: customer.id,
    email: customer.email,
    document: customer.document,
    fullName: customer.fullName,
    phone: customer.phone,
    shippingAddress: customer.shippingAddress,
    billingAddress: customer.billingAddress,
    createdAt: customer.createdAt.toISOString()
  };

  await kafkaProducer.send({
    topic: 'orders.customer-created',
    messages: [{
      key: customer.id,
      value: JSON.stringify(event),
      headers: {
        'event-type': 'customer-created',
        'event-version': '1.0'
      }
    }]
  });
}
```

```typescript
// Serviço Invoices - Consumo e sincronização
async function handleCustomerCreated(event: CustomerCreatedEvent): Promise<void> {
  const customer: InvoicesCustomer = {
    id: crypto.randomUUID(), // ID local do serviço Invoices
    ordersCustomerId: event.customerId,
    email: event.email,
    document: event.document,
    fullName: event.fullName,
    billingAddress: event.billingAddress, // Apenas billing address
    syncedAt: new Date()
  };

  await invoicesDb.customers.create(customer);
  logger.info(`Customer ${event.customerId} synced to Invoices service`);
}
```

```typescript
// Serviço Shipping - Consumo e sincronização
async function handleCustomerCreated(event: CustomerCreatedEvent): Promise<void> {
  const customer: ShippingCustomer = {
    id: crypto.randomUUID(), // ID local do serviço Shipping
    ordersCustomerId: event.customerId,
    email: event.email,
    fullName: event.fullName,
    phone: event.phone || '',
    shippingAddress: event.shippingAddress, // Apenas shipping address
    syncedAt: new Date()
  };

  await shippingDb.customers.create(customer);
  logger.info(`Customer ${event.customerId} synced to Shipping service`);
}
```

## Soft References e Integridade Referencial

### Conceito de Soft References

Em banco de dados relacional tradicional, Foreign Keys garantem integridade referencial. Tentativa de referenciar registro inexistente falha imediatamente. Em microsserviços distribuídos, Foreign Keys atravessando fronteiras de serviço são impossíveis tecnicamente.

Soft References substituem Foreign Keys. São identificadores armazenados sem constraint de integridade do banco de dados. Aplicação assume responsabilidade por manter consistência lógica.

**Características de Soft References**:

**Sem Validação Automática**: Banco de dados não verifica existência de registro referenciado em outro serviço.

**Prefixação por Origem**: Nomear campo indicando serviço de origem facilita rastreamento. Exemplo: `orders_customer_id`, `inventory_product_id`.

**Reconciliação Eventual**: Inconsistências podem surgir temporariamente mas são corrigidas através de processos de reconciliação periódicos ou eventos compensatórios.

**Tratamento de Órfãos**: Aplicação deve decidir como lidar com referências para registros deletados. Soft delete, cascata lógica ou manutenção de referência histórica.

### Implementação Prática

```typescript
// Schema de Invoices com Soft Reference
interface Invoice {
  id: string;
  invoiceNumber: string;
  customerId: string; // FK local para invoices.customers
  ordersCustomerId: string; // Soft reference para orders.customers
  orderId: string; // Soft reference para orders.orders
  totalAmount: number;
  items: InvoiceItem[];
  issuedAt: Date;
  status: 'pending' | 'issued' | 'cancelled';
}

interface InvoiceItem {
  id: string;
  productId: string; // Soft reference para catalog.products
  productName: string; // Dados duplicados para histórico
  quantity: number;
  unitPrice: number;
  totalPrice: number;
}
```

Quando produto é deletado de catálogo, invoices mantêm `productName` duplicado garantindo que notas fiscais históricas permanecem compreensíveis mesmo após produto não existir mais.

### Reconciliação e Auditoria

Processo periódico pode verificar consistência de Soft References:

```typescript
interface ReconciliationReport {
  orphanedReferences: Array<{
    entity: string;
    localId: string;
    foreignService: string;
    foreignId: string;
  }>;
  inconsistentData: Array<{
    entity: string;
    localId: string;
    field: string;
    localValue: any;
    foreignValue: any;
  }>;
}

async function reconcileInvoiceCustomers(): Promise<ReconciliationReport> {
  const report: ReconciliationReport = {
    orphanedReferences: [],
    inconsistentData: []
  };

  const invoiceCustomers = await invoicesDb.customers.findAll();

  for (const customer of invoiceCustomers) {
    // Verifica se customer ainda existe em Orders via API
    try {
      const ordersCustomer = await ordersServiceClient.getCustomer(
        customer.ordersCustomerId
      );

      if (!ordersCustomer) {
        report.orphanedReferences.push({
          entity: 'customer',
          localId: customer.id,
          foreignService: 'orders',
          foreignId: customer.ordersCustomerId
        });
      } else {
        // Verifica consistência de dados
        if (customer.email !== ordersCustomer.email) {
          report.inconsistentData.push({
            entity: 'customer',
            localId: customer.id,
            field: 'email',
            localValue: customer.email,
            foreignValue: ordersCustomer.email
          });
        }
      }
    } catch (error) {
      logger.error(`Failed to reconcile customer ${customer.ordersCustomerId}`, error);
    }
  }

  return report;
}
```

## Transações Distribuídas e Saga Pattern

### Desafio de Transações Atravessando Serviços

Em monolito, operações como "criar pedido, reservar estoque, processar pagamento" executam em única transação ACID. Falha em qualquer etapa automaticamente reverte todas as mudanças.

Em microsserviços, cada operação ocorre em serviço separado com banco de dados próprio. Transações distribuídas tradicionais (Two-Phase Commit) são consideradas antipadrão em microsserviços devido a acoplamento temporal, degradação de performance e complexidade operacional.

### Saga Pattern: Transações como Sequência de Transações Locais

Saga Pattern coordena transações distribuídas através de sequência de transações locais, cada uma com operação compensatória correspondente executada se falha ocorre.

**Dois Estilos de Coordenação**:

**Coreografia**: Serviços publicam eventos e reagem a eventos de outros serviços sem coordenador central. Descentralizado mas pode tornar-se complexo rastrear fluxo.

**Orquestração**: Coordenador central gerencia sequência de passos, invocando serviços e tratando compensações. Centralizado mas mais fácil visualizar e depurar.

### Implementação de Saga Orquestrada

```typescript
import { v4 as uuidv4 } from 'uuid';

interface CreateOrderSagaData {
  customerId: string;
  items: Array<{ productId: string; quantity: number; price: number }>;
  totalAmount: number;
  paymentMethodId: string;
}

interface SagaStep<T = any> {
  name: string;
  execute: (data: T) => Promise<any>;
  compensate: (data: T, executionResult?: any) => Promise<void>;
}

class CreateOrderSagaOrchestrator {
  private sagaId: string;
  private steps: SagaStep<CreateOrderSagaData>[] = [];
  private executedSteps: Array<{ step: SagaStep; result: any }> = [];

  constructor(sagaId?: string) {
    this.sagaId = sagaId || uuidv4();
    this.defineSteps();
  }

  private defineSteps(): void {
    // Passo 1: Reservar estoque
    this.steps.push({
      name: 'reserve-inventory',
      execute: async (data) => {
        const reservationId = await inventoryService.reserveStock({
          sagaId: this.sagaId,
          items: data.items
        });
        return { reservationId };
      },
      compensate: async (data, result) => {
        if (result?.reservationId) {
          await inventoryService.releaseReservation(result.reservationId);
          logger.info(`Inventory reservation ${result.reservationId} released`);
        }
      }
    });

    // Passo 2: Processar pagamento
    this.steps.push({
      name: 'process-payment',
      execute: async (data) => {
        const paymentId = await paymentService.processPayment({
          sagaId: this.sagaId,
          customerId: data.customerId,
          amount: data.totalAmount,
          paymentMethodId: data.paymentMethodId
        });
        return { paymentId };
      },
      compensate: async (data, result) => {
        if (result?.paymentId) {
          await paymentService.refundPayment(result.paymentId);
          logger.info(`Payment ${result.paymentId} refunded`);
        }
      }
    });

    // Passo 3: Criar pedido
    this.steps.push({
      name: 'create-order',
      execute: async (data) => {
        const orderId = await ordersService.createOrder({
          sagaId: this.sagaId,
          customerId: data.customerId,
          items: data.items,
          totalAmount: data.totalAmount,
          status: 'confirmed'
        });
        return { orderId };
      },
      compensate: async (data, result) => {
        if (result?.orderId) {
          await ordersService.cancelOrder(result.orderId);
          logger.info(`Order ${result.orderId} cancelled`);
        }
      }
    });

    // Passo 4: Emitir nota fiscal
    this.steps.push({
      name: 'issue-invoice',
      execute: async (data, previousResults) => {
        const orderId = previousResults.find(r => r.step.name === 'create-order')?.result.orderId;

        const invoiceId = await invoicesService.issueInvoice({
          sagaId: this.sagaId,
          orderId,
          customerId: data.customerId,
          totalAmount: data.totalAmount
        });
        return { invoiceId };
      },
      compensate: async (data, result) => {
        if (result?.invoiceId) {
          await invoicesService.cancelInvoice(result.invoiceId);
          logger.info(`Invoice ${result.invoiceId} cancelled`);
        }
      }
    });
  }

  async execute(data: CreateOrderSagaData): Promise<{ orderId: string }> {
    logger.info(`Starting saga ${this.sagaId} for customer ${data.customerId}`);

    try {
      for (const step of this.steps) {
        logger.info(`Executing step: ${step.name}`);

        const result = await step.execute(data, this.executedSteps);
        this.executedSteps.push({ step, result });

        logger.info(`Step ${step.name} completed successfully`, result);
      }

      const orderId = this.executedSteps
        .find(e => e.step.name === 'create-order')?.result.orderId;

      logger.info(`Saga ${this.sagaId} completed successfully. Order ID: ${orderId}`);
      return { orderId };

    } catch (error) {
      logger.error(`Saga ${this.sagaId} failed at some step`, error);
      await this.compensate();
      throw new Error(`Order creation failed: ${error.message}`);
    }
  }

  private async compensate(): Promise<void> {
    logger.info(`Starting compensation for saga ${this.sagaId}`);

    // Executa compensações em ordem reversa
    for (let i = this.executedSteps.length - 1; i >= 0; i--) {
      const { step, result } = this.executedSteps[i];

      try {
        logger.info(`Compensating step: ${step.name}`);
        await step.compensate(null as any, result);
        logger.info(`Step ${step.name} compensated successfully`);
      } catch (compensationError) {
        logger.error(`Compensation failed for step ${step.name}`, compensationError);
        // Em cenário real, pode ser necessário alerta manual ou retry
      }
    }

    logger.info(`Compensation for saga ${this.sagaId} completed`);
  }
}

// Uso
const saga = new CreateOrderSagaOrchestrator();
const result = await saga.execute({
  customerId: 'cust-123',
  items: [
    { productId: 'prod-456', quantity: 2, price: 29.99 },
    { productId: 'prod-789', quantity: 1, price: 149.99 }
  ],
  totalAmount: 209.97,
  paymentMethodId: 'pm-abc'
});
```

Este orquestrador garante que se qualquer passo falha, todos os passos anteriores são compensados, revertendo estado do sistema mesmo sem transação ACID global.

## Event Sourcing e CQRS

### Event Sourcing: Estado como Sequência de Eventos

Event Sourcing inverte modelo tradicional de persistência. Ao invés de armazenar estado atual sobrescrevendo valores anteriores, armazena-se sequência imutável de eventos representando todas as mudanças.

**Vantagens de Event Sourcing**:

**Auditoria Completa**: Histórico completo de todas as mudanças. Útil para compliance, debugging e análise de comportamento.

**Reconstrução de Estado**: Estado atual pode ser reconstruído reproduzindo eventos. Permite criar novas projeções de dados históricos.

**Temporal Queries**: Consultar estado do sistema em qualquer ponto temporal passado.

**Event-Driven por Natureza**: Eventos armazenados servem também como mensagens para comunicação assíncrona.

```typescript
// Eventos representam fatos imutáveis que ocorreram
type OrderEvent =
  | {
      type: 'ORDER_CREATED';
      orderId: string;
      customerId: string;
      items: Array<{ productId: string; quantity: number; price: number }>;
      totalAmount: number;
      createdAt: Date;
    }
  | {
      type: 'PAYMENT_PROCESSED';
      orderId: string;
      paymentId: string;
      amount: number;
      processedAt: Date;
    }
  | {
      type: 'ORDER_SHIPPED';
      orderId: string;
      trackingNumber: string;
      shippedAt: Date;
    }
  | {
      type: 'ORDER_DELIVERED';
      orderId: string;
      deliveredAt: Date;
    }
  | {
      type: 'ORDER_CANCELLED';
      orderId: string;
      reason: string;
      cancelledAt: Date;
    };

// Event Store persistência de eventos
interface StoredEvent {
  eventId: string;
  aggregateId: string;
  aggregateType: string;
  eventType: string;
  eventData: any;
  eventVersion: number;
  occurredAt: Date;
}

class EventStore {
  async appendEvent(event: OrderEvent, aggregateId: string): Promise<void> {
    const storedEvent: StoredEvent = {
      eventId: crypto.randomUUID(),
      aggregateId,
      aggregateType: 'Order',
      eventType: event.type,
      eventData: event,
      eventVersion: await this.getNextVersion(aggregateId),
      occurredAt: new Date()
    };

    await db.events.create(storedEvent);
  }

  async getEvents(aggregateId: string): Promise<OrderEvent[]> {
    const stored = await db.events.findMany({
      where: { aggregateId, aggregateType: 'Order' },
      orderBy: { eventVersion: 'asc' }
    });

    return stored.map(e => e.eventData as OrderEvent);
  }

  private async getNextVersion(aggregateId: string): Promise<number> {
    const lastEvent = await db.events.findFirst({
      where: { aggregateId },
      orderBy: { eventVersion: 'desc' }
    });

    return lastEvent ? lastEvent.eventVersion + 1 : 1;
  }
}

// Aggregate reconstrói estado a partir de eventos
class OrderAggregate {
  private orderId: string;
  private customerId: string;
  private totalAmount: number;
  private status: 'pending' | 'paid' | 'shipped' | 'delivered' | 'cancelled';
  private events: OrderEvent[] = [];

  constructor(orderId: string) {
    this.orderId = orderId;
  }

  // Reconstrói estado aplicando eventos
  static async loadFromEvents(orderId: string, eventStore: EventStore): Promise<OrderAggregate> {
    const aggregate = new OrderAggregate(orderId);
    const events = await eventStore.getEvents(orderId);

    for (const event of events) {
      aggregate.apply(event);
    }

    return aggregate;
  }

  private apply(event: OrderEvent): void {
    this.events.push(event);

    switch (event.type) {
      case 'ORDER_CREATED':
        this.customerId = event.customerId;
        this.totalAmount = event.totalAmount;
        this.status = 'pending';
        break;

      case 'PAYMENT_PROCESSED':
        this.status = 'paid';
        break;

      case 'ORDER_SHIPPED':
        this.status = 'shipped';
        break;

      case 'ORDER_DELIVERED':
        this.status = 'delivered';
        break;

      case 'ORDER_CANCELLED':
        this.status = 'cancelled';
        break;
    }
  }

  getState() {
    return {
      orderId: this.orderId,
      customerId: this.customerId,
      totalAmount: this.totalAmount,
      status: this.status
    };
  }
}
```

### CQRS: Separação de Leitura e Escrita

Command Query Responsibility Segregation separa modelos de escrita (command) e leitura (query). Escritas modificam Event Store. Leituras consultam projeções otimizadas construídas a partir de eventos.

```typescript
// Command Model - Processa comandos gerando eventos
class OrderCommandHandler {
  constructor(private eventStore: EventStore) {}

  async createOrder(command: {
    customerId: string;
    items: Array<{ productId: string; quantity: number; price: number }>;
  }): Promise<string> {
    const orderId = crypto.randomUUID();
    const totalAmount = command.items.reduce(
      (sum, item) => sum + item.price * item.quantity,
      0
    );

    const event: OrderEvent = {
      type: 'ORDER_CREATED',
      orderId,
      customerId: command.customerId,
      items: command.items,
      totalAmount,
      createdAt: new Date()
    };

    await this.eventStore.appendEvent(event, orderId);
    return orderId;
  }

  async shipOrder(orderId: string, trackingNumber: string): Promise<void> {
    const event: OrderEvent = {
      type: 'ORDER_SHIPPED',
      orderId,
      trackingNumber,
      shippedAt: new Date()
    };

    await this.eventStore.appendEvent(event, orderId);
  }
}

// Query Model - Projeções otimizadas para leitura
interface OrderProjection {
  orderId: string;
  customerId: string;
  customerName: string;
  totalAmount: number;
  status: string;
  itemCount: number;
  createdAt: Date;
  lastUpdatedAt: Date;
}

class OrderProjectionBuilder {
  async buildProjection(event: OrderEvent): Promise<void> {
    switch (event.type) {
      case 'ORDER_CREATED':
        await db.orderProjections.create({
          data: {
            orderId: event.orderId,
            customerId: event.customerId,
            totalAmount: event.totalAmount,
            status: 'pending',
            itemCount: event.items.length,
            createdAt: event.createdAt,
            lastUpdatedAt: event.createdAt
          }
        });
        break;

      case 'PAYMENT_PROCESSED':
        await db.orderProjections.update({
          where: { orderId: event.orderId },
          data: {
            status: 'paid',
            lastUpdatedAt: event.processedAt
          }
        });
        break;

      case 'ORDER_SHIPPED':
        await db.orderProjections.update({
          where: { orderId: event.orderId },
          data: {
            status: 'shipped',
            lastUpdatedAt: event.shippedAt
          }
        });
        break;
    }
  }
}

// Query Service - Leituras otimizadas
class OrderQueryService {
  async getOrderById(orderId: string): Promise<OrderProjection | null> {
    return await db.orderProjections.findUnique({ where: { orderId } });
  }

  async getCustomerOrders(customerId: string): Promise<OrderProjection[]> {
    return await db.orderProjections.findMany({
      where: { customerId },
      orderBy: { createdAt: 'desc' }
    });
  }

  async getOrdersByStatus(status: string): Promise<OrderProjection[]> {
    return await db.orderProjections.findMany({
      where: { status },
      orderBy: { createdAt: 'desc' }
    });
  }
}
```

## Conclusão

A persistência de dados em microsserviços representa mudança paradigmática fundamental comparado a arquiteturas monolíticas tradicionais. O princípio Database per Service, embora introduza complexidades substanciais, habilita independência operacional, autonomia tecnológica e escalabilidade granular essenciais para microsserviços eficazes.

A duplicação controlada de dados, implementada através de sincronização via eventos e Soft References, substitui relacionamentos diretos via Foreign Keys. Esta abordagem sacrifica consistência forte imediata em favor de consistência eventual e autonomia de serviços. Desenvolvedores devem compreender profundamente trade-offs entre consistência e disponibilidade conforme Teorema CAP e implementar estratégias apropriadas para seus contextos específicos.

Transações distribuídas coordenadas via Saga Pattern permitem operações complexas atravessando múltiplos serviços mantendo integridade lógica sem acoplamento temporal de Two-Phase Commit. Orquestração ou coreografia de Sagas oferece mecanismos compensatórios para falhas, embora aumentem complexidade comparado a transações ACID simples de monolitos.

Event Sourcing e CQRS representam padrões avançados que, quando apropriados, fornecem auditoria completa, capacidade de reconstrução temporal e separação otimizada entre comandos e queries. Entretanto, introduzem complexidade operacional significativa e devem ser adotados apenas quando benefícios justificam custos.

O domínio destes conceitos e padrões de persistência distribuída é essencial para arquitetos e desenvolvedores construindo sistemas de microsserviços robustos, escaláveis e resilientes. A escolha apropriada de estratégias de persistência impacta diretamente consistência, disponibilidade, performance e complexidade operacional do sistema distribuído.

## Referências Bibliográficas

**Padrões e Práticas**

Richardson, Chris. Microservices.io - Data Patterns. Disponível em: https://microservices.io/patterns/data/

Fowler, Martin. Event Sourcing. Disponível em: https://martinfowler.com/eaaDev/EventSourcing.html

Microsoft Azure Architecture Center. Data considerations for microservices. Disponível em: https://learn.microsoft.com/azure/architecture/microservices/design/data-considerations

**Bancos de Dados**

PostgreSQL Global Development Group. PostgreSQL Documentation. Disponível em: https://www.postgresql.org/docs/

MongoDB, Inc. MongoDB Documentation. Disponível em: https://www.mongodb.com/docs/

Redis Ltd. Redis Documentation. Disponível em: https://redis.io/docs/

Apache Cassandra. Cassandra Documentation. Disponível em: https://cassandra.apache.org/doc/

Elastic. Elasticsearch Guide. Disponível em: https://www.elastic.co/guide/

**Event Sourcing e CQRS**

AxonIQ. Axon Framework Documentation. Disponível em: https://docs.axoniq.io/

Event Store Ltd. EventStore Documentation. Disponível em: https://www.eventstore.com/documentation

Young, Greg. CQRS Documents. Disponível em: https://cqrs.files.wordpress.com/

**Transações Distribuídas**

Apache Software Foundation. Apache Kafka - Transactions. Disponível em: https://kafka.apache.org/documentation/#transactions

Richardson, Chris. Saga Pattern. Microservices.io. Disponível em: https://microservices.io/patterns/data/saga.html

**Práticas de Dados Distribuídos**

Amazon Web Services. Database per microservice. Disponível em: https://aws.amazon.com/microservices/

Brewer, Eric. CAP Theorem. UC Berkeley.

## Apêndice A: Comparação de Tecnologias de Banco de Dados

### PostgreSQL

**Tipo**: Relacional (RDBMS)

**Casos de Uso Ideais**: Dados transacionais estruturados, integridade referencial complexa, queries analíticas com JOINs.

**Vantagens**: ACID completo, suporte JSON, extensibilidade, performance excelente.

**Desvantagens**: Escalabilidade horizontal complexa, overhead para dados não estruturados.

### MongoDB

**Tipo**: NoSQL Orientado a Documentos

**Casos de Uso Ideais**: Dados semi-estruturados, esquemas flexíveis, desenvolvimento rápido com mudanças frequentes de schema.

**Vantagens**: Flexibilidade de schema, escalabilidade horizontal nativa, queries poderosas em documentos.

**Desvantagens**: Sem ACID completo multi-documento (em versões antigas), consumo de memória.

### Redis

**Tipo**: In-Memory Key-Value Store

**Casos de Uso Ideais**: Caching, sessões, contadores, pub/sub, dados temporários de alta velocidade.

**Vantagens**: Performance extremamente alta, estruturas de dados ricas, simplicidade.

**Desvantagens**: Limitado por memória RAM, persistência opcional com trade-offs.

### ClickHouse

**Tipo**: Columnar Database for Analytics

**Casos de Uso Ideais**: Analytics de séries temporais, agregações em grandes volumes, data warehousing.

**Vantagens**: Performance analítica excepcional, compressão eficiente, queries complexas rápidas.

**Desvantagens**: Otimizado para leitura, escritas menos eficientes, não adequado para transações OLTP.

## Apêndice B: Estratégias de Migração de Monolito

### Abordagem Incremental

**Passo 1 - Identificar Bounded Contexts**: Mapear domínios de negócio e fronteiras naturais.

**Passo 2 - Extrair Serviço Independente**: Começar com serviço de menor acoplamento.

**Passo 3 - Duplicar Dados Necessários**: Implementar sincronização via eventos.

**Passo 4 - Migrar Tráfego Gradualmente**: API Gateway roteia requisições para novo serviço progressivamente.

**Passo 5 - Remover Código do Monolito**: Após validação, limpar código legado.

**Passo 6 - Repetir**: Iterar processo para próximos domínios.

### Padrão Strangler Fig

Novo sistema gradualmente "estrangula" monolito, assumindo funcionalidades incrementalmente até monolito tornar-se obsoleto.

## Apêndice C: Glossário e Termos Técnicos

**ACID**: Atomicity, Consistency, Isolation, Durability - propriedades de transações em bancos de dados tradicionais.

**Aggregate**: Conjunto de objetos de domínio tratados como unidade para mudanças de dados (DDD).

**Bounded Context**: Fronteira explícita dentro da qual modelo de domínio específico é aplicável (DDD).

**CAP Theorem**: Teorema estabelecendo que sistemas distribuídos podem garantir apenas duas de três propriedades: Consistency, Availability, Partition Tolerance.

**Command**: Operação que modifica estado do sistema (CQRS).

**Consistência Eventual**: Garantia que sistema convergirá para estado consistente dado tempo suficiente sem novas atualizações.

**CQRS**: Command Query Responsibility Segregation - separação de modelos de leitura e escrita.

**Database per Service**: Padrão onde cada microsserviço possui banco de dados isolado.

**Event Sourcing**: Padrão armazenando mudanças de estado como sequência imutável de eventos.

**Foreign Key**: Constraint de banco de dados garantindo integridade referencial entre tabelas.

**Projection**: Visão materializada de dados construída a partir de eventos (Event Sourcing/CQRS).

**Query**: Operação que lê estado sem modificá-lo (CQRS).

**Saga Pattern**: Padrão para gerenciar transações distribuídas através de transações locais e compensações.

**Soft Delete**: Marcar registro como deletado sem removê-lo fisicamente do banco.

**Soft Reference**: Identificador armazenado sem constraint de integridade referencial do banco de dados.

**Source of Truth**: Serviço ou banco de dados autoritativo para determinada entidade ou conjunto de dados.

**Two-Phase Commit (2PC)**: Protocolo de transação distribuída garantindo atomicidade através de prepare e commit phases. Considerado antipadrão em microsserviços.
